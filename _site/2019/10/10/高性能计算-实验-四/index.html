<!DOCTYPE html><html><head><title> 高性能计算·实验（四） &middot; wu-kan</title><!-- Begin Jekyll SEO tag v2.7.1 --><meta name="generator" content="Jekyll v3.9.0" /><meta property="og:title" content="高性能计算·实验（四）" /><meta property="og:locale" content="en_US" /><meta name="description" content="实现并行梯形数值积分的 MPI 算法" /><meta property="og:description" content="实现并行梯形数值积分的 MPI 算法" /><link rel="canonical" href="http://localhost:4000/2019/10/10/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97-%E5%AE%9E%E9%AA%8C-%E5%9B%9B/" /><meta property="og:url" content="http://localhost:4000/2019/10/10/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97-%E5%AE%9E%E9%AA%8C-%E5%9B%9B/" /><meta property="og:site_name" content="wu-kan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-10T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="高性能计算·实验（四）" /><meta name="google-site-verification" content="YIKi1rBnyUaS-DMYiluseI5kZzTwjCkTFmKkSkMZDJk" /><meta name="baidu-site-verification" content="szbTSfUGAB" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"http://localhost:4000/2019/10/10/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97-%E5%AE%9E%E9%AA%8C-%E5%9B%9B/","datePublished":"2019-10-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/10/10/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97-%E5%AE%9E%E9%AA%8C-%E5%9B%9B/"},"headline":"高性能计算·实验（四）","description":"实现并行梯形数值积分的 MPI 算法","dateModified":"2019-10-10T00:00:00+08:00","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" /><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="alternate" href="/feed.xml" title="RSS" type="application/rss+xml" /><link rel="apple-touch-icon-precomposed" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" /><link rel="shortcut icon" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=32" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/poole/lanyon@v1.1.0/public/css/poole.min.css,gh/poole/lanyon@v1.1.0/public/css/lanyon.min.css,gh/poole/lanyon@v1.1.0/public/css/syntax.min.css" /> <script async="async" src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/js/all.min.js" ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dreamer-Paul/Pio@2.4/static/pio.min.css" /><style> @media only print { .pio-container { display: none; } }</style><script async="async" src="https://cdn.jsdelivr.net/combine/gh/Dreamer-Paul/Pio@2.4/static/l2d.min.js,gh/Dreamer-Paul/Pio@2.4/static/pio.min.js" onload=' let pio_container = document.createElement("div"); pio_container.classList.add("pio-container"); pio_container.classList.add("right"); pio_container.style.bottom = "-2rem"; pio_container.style.zIndex = "1"; document.body.insertAdjacentElement("beforeend", pio_container); let pio_action = document.createElement("div"); pio_action.classList.add("pio-action"); pio_container.insertAdjacentElement("beforeend", pio_action); let pio_canvas = document.createElement("canvas"); pio_canvas.id = "pio"; pio_canvas.style.width = "14rem"; pio_canvas.width = "600"; pio_canvas.height = "800"; pio_container.insertAdjacentElement("beforeend", pio_canvas); let pio = new Paul_Pio({ "mode": "fixed", "hidden": true, "night": "for(let i=7; i<16; ++i) if(document.body.classList.contains(`theme-base-0`+i.toString(16))) { document.body.classList.remove(`theme-base-0`+i.toString(16)); document.body.classList.add(`theme-base-0`+((i-6)%9+7).toString(16)); break; }", "content": { "link": ["https:\/\/jekyll-theme-WuK.wu-kan.cn"], "skin": ["要换成我的朋友吗？", "让她放个假吧~"], "hidden": true, "custom": [{ "selector": "a", "type": "link", }, { "selector": ".sidebar-toggle", "text": "打开侧边栏叭~" }, { "selector": ".effect-info", "text": "哇，你发现了什么！" }, { "selector": "#sidebar-search-input", "text": "想搜索什么呢？很多干货哦！" }, { "selector": "#toc", "text": "这是目录~" }, { "selector": ".page-title", "text": "这是标题~" }, { "selector": ".v", "text": "评论没有审核，要对自己的发言负责哦~" }] }, "model": [ "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/33/model.2018.bls-winter.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/platelet-2/model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/xiaomai/xiaomai.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/mashiro/seifuku.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/Violet/14.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/Kobayaxi/Kobayaxi.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/mikoto/mikoto.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/uiharu/uiharu.model.json"] });' ></script> <script src='https://zz.bdstatic.com/linksubmit/push.js' async="async" ></script><style> .wrap { transition-property: width,background-size,transform; transition-duration: .3s; transition-timing-function: ease-in-out; min-height: 100%; display: inline-block; background-size: 100% auto; background-position: 0% 0%; background-repeat: no-repeat; background-attachment: fixed; background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/74559485_p1.webp); } @media (min-aspect-ratio: 2400/1850) { .wrap { background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/71932901_p0.webp); } } .sidebar-overlay #sidebar-checkbox:checked ~ .wrap { width: calc(100% - 14rem); background-size: calc(100% - 14rem) auto; transform: translateX(14rem); } .layout-reverse.sidebar-overlay #sidebar-checkbox:checked ~ .wrap { transform: translateX(0); }</style><style> .sidebar, html, h1, h2, h3, h4, h5, h6 { font-family: "Courier New", "Courier", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Microsoft YaHei Light", "Microsoft JhengHei", monospace; }</style><style> td, th { padding: 0px; border: 0px; } table { border: 0px; } table tbody { display: block; overflow: scroll; } table thead, tbody tr { display: table; table-layout: fixed; width: 100%; }</style><style> img { display: inline-block; margin: 0; }</style><style> ::-webkit-scrollbar { width: 3px; height: 3px; } ::-webkit-scrollbar-thumb { background-image: linear-gradient(45deg, Cyan 0%, Magenta 50%, Yellow 100%); }</style><style> ::selection { color: White; background: Black; }</style><body class="theme-base-0d layout-reverse sidebar-overlay"> <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. --> <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" /> <!-- Toggleable sidebar --><div class="sidebar" id="sidebar"><div class="sidebar-item"><div class="effect effect-right_to_left"> <img class="effect-img" src="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" alt="img" /><div class="effect-info"> SYSU超算17级在读<br/> 水野爱<br/> HPC<br/> 田宫例四驱车<br/> <a href="mailto:i@wu-kan.cn"> <i class="fas fa-envelope"></i> </a> <a href="https://github.com/wu-kan"> <i class="fab fa-github"></i> </a> <a href="https://codeforces.com/profile/WuK"> <i class="fas fa-chart-bar"></i> </a> <a href="https://vjudge.net/user/WuK"> <i class="fas fa-smile"></i> </a> <a href="https://www.zhihu.com/people/wu.kan/activities"> <i class="fab fa-zhihu"></i> </a> <iframe src="https://music.163.com/outchain/player?type=0&id=155059595&auto=0&height=32" width=100% height=52 frameborder="no" border="0" marginwidth="0" marginheight="0" ></iframe></div></div></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/"> <i class="fas fa-home fa-fw"></i> 首页 </a> <a class="sidebar-nav-item" href="/comments/"> <i class="fas fa-comments fa-fw"></i> 留言 </a> <a class="sidebar-nav-item" href="/tags/"> <i class="fas fa-tags fa-fw"></i> 标签 </a> <a class="sidebar-nav-item" href="/archive/"> <i class="fas fa-archive fa-fw"></i> 归档 </a> <a class="sidebar-nav-item" href="/merger/"> <i class="fas fa-coffee fa-fw"></i> 打赏 </a></nav><div class="sidebar-item"><style> #sidebar-search-input { background: none; border: none; color: White; width: 100%; } #sidebar-search-results-container { overflow: auto auto; max-height: 66.6vh; }</style><input id="sidebar-search-input" placeholder="搜索博文" /><ol id="sidebar-search-results-container" ></ol><script src='https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.9.1' async='async' onload=' SimpleJekyllSearch({ json: "/assets/simple-jekyll-search/search.json", searchInput: document.getElementById("sidebar-search-input"), resultsContainer: document.getElementById("sidebar-search-results-container"), searchResultTemplate: `<li><a href="{url}">{title}</a>`, limit: 999, fuzzy: true })' ></script><style> #toc { overflow: auto auto; max-height: 66.6vh; }</style><ol id="toc"><li><a href="#%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C%E6%A2%AF%E5%BD%A2%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E7%9A%84-mpi-%E7%AE%97%E6%B3%95">实现并行梯形数值积分的 MPI 算法</a><ol><li><a href="#%E7%94%A8-mpi-%E7%9A%84%E7%82%B9%E5%AF%B9%E7%82%B9%E9%80%9A%E4%BF%A1%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E6%A2%AF%E5%BD%A2%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95">用 MPI 的点对点通信函数完成梯形数值积分的并行算法</a><li><a href="#%E7%94%A8-mpi-%E7%9A%84%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E6%A2%AF%E5%BD%A2%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95">用 MPI 的集合通信函数完成梯形数值积分的并行算法</a><li><a href="#%E5%B0%86%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%AE%97%E6%B3%95%E5%AF%B9%E7%91%95%E7%A7%AF%E5%88%86%E6%89%A9%E5%B1%95">将上面的算法对瑕积分扩展</a><li><a href="#%E5%A1%AB%E8%A1%A8">填表</a><ol><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4-t%E5%8D%95%E4%BD%8D-s">运行时间 T（单位 s）</a><li><a href="#%E5%8A%A0%E9%80%9F%E6%AF%94-s">加速比 S</a><li><a href="#%E6%95%88%E7%8E%87-e">效率 E</a></ol><li><a href="#%E6%BA%90%E4%BB%A3%E7%A0%81integralc">源代码integral.c</a><li><a href="#%E4%BD%9C%E4%B8%9A%E8%84%9A%E6%9C%ACintegralpbs">作业脚本integral.pbs</a><li><a href="#%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6integralo1761">输出文件integral.o1761</a></ol><li><a href="#%E5%AE%8C%E6%88%90%E6%AD%A3%E5%88%99%E9%87%87%E6%A0%B7%E6%8E%92%E5%BA%8F-psrs-%E7%9A%84-mpi-%E7%AE%97%E6%B3%95">完成正则采样排序 PSRS 的 MPI 算法</a><ol><li><a href="#psrsc">psrs.c</a><li><a href="#psrspbs">psrs.pbs</a><li><a href="#psrso1529">psrs.o1529</a><li><a href="#%E5%A1%AB%E8%A1%A8-1">填表</a><ol><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4-t%E5%8D%95%E4%BD%8D-s-1">运行时间 T（单位 s）</a><li><a href="#%E5%8A%A0%E9%80%9F%E6%AF%94-s-1">加速比 S</a><li><a href="#%E6%95%88%E7%8E%87-e-1">效率 E</a></ol></ol></ol><style> .sidebar-checkbox { display: none; } .sidebar-toggle { position: fixed; }</style><style> .sidebar { overflow: scroll; min-height: 101%; }</style><style> .effect { margin: 1rem; perspective: 900px; } .effect-info { text-align: center; position: absolute; top: 0; transform-style: preserve-3d; } .effect-img { z-index: 11; width: 100%; height: 100%; position: relative; transition: all 0.5s ease-in-out; } .effect-img:before { position: absolute; display: block; } .effect-right_to_left .effect-img { transform-origin: 0% 50%; } .effect-right_to_left:hover .effect-img { transform: rotate3d(0, 1, 0, -180deg); }</style><div> <i class="fas fa-cog fa-spin fa-fw"></i> <span id="run_time_day"> <i class="fas fa-spinner fa-pulse"></i> </span>天 <span id="run_time_hour"> <i class="fas fa-spinner fa-pulse"></i> </span>时 <span id="run_time_minute"> <i class="fas fa-spinner fa-pulse"></i> </span>分 <span id="run_time_second"> <i class="fas fa-spinner fa-pulse"></i> </span>秒 <script> setInterval(function (d,h,m,s,b) { function setzero(i) { return i < 10 ? "0" + i : i; } let BirthDay = new Date(b); let today = new Date(); let timeold = (today.getTime() - BirthDay.getTime()); let sectimeold = timeold / 1000; let secondsold = Math.floor(sectimeold); let msPerDay = 24 * 60 * 60 * 1000; let e_daysold = timeold / msPerDay; let daysold = Math.floor(e_daysold); let e_hrsold = (e_daysold - daysold) * 24; let hrsold = Math.floor(e_hrsold); let e_minsold = (e_hrsold - hrsold) * 60; let minsold = Math.floor((e_hrsold - hrsold) * 60); let seconds = Math.floor((e_minsold - minsold) * 60); d.textContent = daysold; h.textContent = setzero(hrsold); m.textContent = setzero(minsold); s.textContent = setzero(seconds); }, 1000, document.getElementById("run_time_day"), document.getElementById("run_time_hour"), document.getElementById("run_time_minute"), document.getElementById("run_time_second"), "10/04/2017 11:03:56")// 这是我第一篇CSDN博客的时间 </script></div><div><div> <i class="fas fa-eye fa-fw"></i> <span id="busuanzi_value_page_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>次</div><div> <i class="fas fa-paw fa-fw"></i> <span id="busuanzi_value_site_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>枚</div><div> <i class="fas fa-user-friends fa-fw"></i> <span id="busuanzi_value_site_uv"> <i class="fas fa-spinner fa-pulse"></i> </span>人</div><script src='https://cdn.jsdelivr.net/npm/busuanzi@2.3.0' async='async' ></script></div><div> <i class="fas fa-thumbs-up fa-fw"></i> <a href="https://jekyll-theme-WuK.wu-kan.cn"> jekyll-theme-WuK </a></div><div> <i class="fas fa-copyright fa-fw"></i> 2017-2021 WuK</div><div> <i class="fas fa-info-circle fa-fw"></i> <a href="http://beian.miit.gov.cn"> 粤ICP备 20024947号 </a></div><div> <img src="https://i.loli.net/2021/03/17/Y47tDZTrcy2xwRa.png" class="fa-fw"></img> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=34070202000407"> 皖公网安备 34070202000407号 </a></div></div></div><!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --><div class="wrap"><style> @media only screen { pre { max-height: 66.6vh; overflow: auto; } }</style><style> .container { min-width: 66.6%; } @media only print { .container { min-width: 100%; } }</style><style> .container.content { padding: 2rem; box-shadow: 0 0 2rem rgba(255,255,255,0.9); background-color: rgba(255,255,255,0.9); animation-duration: 2s; animation-name: fadeIn; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }</style><div class="container content"><div class="page"><h1 class="page-title">高性能计算·实验（四）</h1><div class="post"> <span class="post-date"> <i class="fas fa-calendar-day fa-fw"></i> 10 Oct 2019 <i class="fas fa-file-word fa-fw"></i> 11497字 <i class="fas fa-clock fa-fw"></i> 39分 <br/> <i class="fas fa-coffee fa-fw"></i> <a href="/merger/">如果这篇博客帮助到你，可以请我喝一杯咖啡~</a> <br/> <i class="fab fa-creative-commons-by fa-fw"></i> <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="license"> CC BY 4.0 </a> （除特别声明或转载文章外） </span><h2 id="实现并行梯形数值积分的-mpi-算法">实现并行梯形数值积分的 MPI 算法</h2><p>下为单节点求解$\int_{a}^bf(x)dx$的函数，其中<code>e</code>是逼近的步长。由于单账号的运行时间权限是一个小时，这里我经过调参，取<code>e=1e-2</code>是可以在时限内计算完毕的（约四十分钟）。</p><pre><code class="language-c">lf ask(lf a, lf b, lf f(lf x), lf e)
{
	lf ans = 0, fa = f(a);
	while (a &lt; b)
	{
		lf fb = f(a += e);
		ans += fa + fb;
		fa = fb;
	}
	return ans * e * 0.5;
}
</code></pre><p>这里有几处优化细节，通过调整求值关系，使得每个点处的函数值不被重复计算；同时把梯形的高移动到循环外面，减少计算次数。</p><p>当然，由于这里的步长其实只有百分之一，因此最后求出来的积分其实精度不怎么高，和自己手算的结果相比只能保证五六位的有效位数。</p><h3 id="用-mpi-的点对点通信函数完成梯形数值积分的并行算法">用 MPI 的点对点通信函数完成梯形数值积分的并行算法</h3><p>各进程将各自计算的结果<code>myAns</code>发送到 0 号进程并求和<code>ans</code>。</p><pre><code class="language-c">	if (!id)
	{
		for (int i = 1; i &lt; numThreads; ++i)
		{
			MPI_Recv(
				&amp;myAns,
				1,
				MPI_DOUBLE,
				i,
				0,
				MPI_COMM_WORLD,
				MPI_STATUES_IGNORE);
			ans += myAns;
		}
	}
	else
		MPI_Send(
			&amp;myAns,
			1,
			MPI_DOUBLE,
			0,
			0,
			MPI_COMM_WORLD);
</code></pre><h3 id="用-mpi-的集合通信函数完成梯形数值积分的并行算法">用 MPI 的集合通信函数完成梯形数值积分的并行算法</h3><p>使用<code>Reduce</code>操作将各线程的结果<code>myAns</code>归约到 0 号进程的<code>ans</code>。</p><pre><code class="language-c">	MPI_Reduce(
		&amp;myAns,
		&amp;ans,
		1,
		MPI_DOUBLE,
		MPI_SUM,
		0,
		MPI_COMM_WORLD);
</code></pre><h3 id="将上面的算法对瑕积分扩展">将上面的算法对瑕积分扩展</h3><p>假设被积函数 f(x)可能是无界函数，积分区间也很大，如</p><ul><li>f(x)=exp(bx)/sqrt(1+exp(cx)), 0&lt;x&lt;=L;<li>这时积分区间[0,L]划分不能是等长的，每个任务的小区间需要传递，并且参数 b，c，L 也需要传递。</ul><p>这里选择使用自适应辛普森方法求解瑕积分，根据<a href="http://www2.math.umd.edu/~mariakc/teaching/adaptive.pdf">这篇论文</a>，论证了加一个十五分之一的偏移收敛会比较快。</p><pre><code class="language-c">lf f(lf x)
{
	return exp(x) / sqrt(1 + exp(x));
}
lf simpson(lf a, lf b, lf f(lf x))
{
	if (fabs(a) &lt; EPS)
		return f((a + b) * 0.5) * (b - a);
	return (f(a) + 4 * f((a + b) * 0.5) + f(b)) * (b - a) / 6;
}
lf ask(lf a, lf b, lf f(lf x), lf e)
{
	if (e &lt; EPS)
		return simpson(a, b, f);
	lf c = (a + b) * 0.5, L = simpson(a, c, f), R = simpson(c, b, f), delta = (L + R - simpson(a, b, f)) / 15;
	return fabs(delta) &lt; e ? L + R + delta : ask(a, c, f, e * 0.5) + ask(c, b, f, e * 0.5);
}
</code></pre><p>不过，在对老师给的这个函数（取<code>b = c = 1</code>）进行瑕积分求解的时候，发现积分上限达到$2^{10}$的时候，结果已经超过了<code>double</code>类型的表示范围，因此这段代码仅用来验证瑕积分求解的正确性，下面进行多核测速的代码仍然使用的是梯形积分法。</p><pre><code class="language-bash">$ time mpiexec -n 1 ./integral 9
3022859422404135022056366724809190601572944773201862114369138391962853640177743445854646916709852400063199838208.000000 with 1 proces, problem size 512.
real    0m0.058s
user    0m0.000s
sys     0m0.063s
$ time mpiexec -n 1 ./integral 10
-nan with 1 proces, problem size 1024.
real    0m0.058s
user    0m0.000s
sys     0m0.047s
</code></pre><h3 id="填表">填表</h3><h4 id="运行时间-t单位-s">运行时间 T（单位 s）</h4><p>详见下面的输出文件部分。</p><table><thead><tr><th>进程数\问题规模<th>$2^{14}$<th>$2^{18}$<th>$2^{22}$<th>$2^{26}$<th>$2^{30}$<th>$2^{31}$<th>$2^{32}$<tbody><tr><td>1<td>0.424<td>0.513<td>1.928<td>23.536<td>357.396<td>706.644<td>1441.164<tr><td>2<td>0.426<td>0.553<td>1.403<td>11.794<td>182.182<td>354.155<td>706.369<tr><td>4<td>0.466<td>0.542<td>1.019<td>6.230<td>92.010<td>179.062<td>353.818<tr><td>8<td>0.543<td>0.487<td>0.716<td>3.667<td>46.014<td>92.823<td>177.530<tr><td>16<td>0.541<td>0.576<td>0.719<td>2.177<td>23.253<td>46.102<td>93.670<tr><td>32<td>0.898<td>0.747<td>0.826<td>1.663<td>12.633<td>23.169<td>45.404<tr><td>64<td>1.464<td>1.067<td>1.116<td>1.638<td>6.812<td>12.324<td>23.790<tr><td>128<td>1.110<td>1.076<td>1.176<td>1.416<td>4.105<td>6.952<td>12.525<tr><td>256<td>1.534<td>1.188<td>1.196<td>1.319<td>2.848<td>4.110<td>6.936<tr><td>512<td>1.802<td>1.704<td>1.695<td>1.754<td>2.210<td>2.626<td>3.478</table><p>可以看到：</p><ul><li>随着问题规模增加，同进程数下运行时间不断增加<li>问题规模比较小的时候，进程越多并行时间开销越大<li>问题规模比较大的时候，运行时间减少</ul><h4 id="加速比-s">加速比 S</h4><p>加速比 S=同等规模下的串行时间/并行时间。</p><table><thead><tr><th>进程数\问题规模<th>$2^{14}$<th>$2^{18}$<th>$2^{22}$<th>$2^{26}$<th>$2^{30}$<th>$2^{31}$<th>$2^{32}$<tbody><tr><td>1<td>1.00<td>1.00<td>1.00<td>1.00<td>1.00<td>1.00<td>1.00<tr><td>2<td>1.00<td>0.93<td>1.37<td>2.00<td>1.96<td>2.00<td>2.04<tr><td>4<td>0.91<td>0.95<td>1.89<td>3.78<td>3.88<td>3.94<td>4.07<tr><td>8<td>0.78<td>1.05<td>2.69<td>6.41<td>7.77<td>7.61<td>8.12<tr><td>16<td>0.78<td>0.89<td>2.68<td>10.81<td>15.37<td>15.33<td>15.39<tr><td>32<td>0.47<td>0.69<td>2.33<td>14.15<td>28.29<td>30.50<td>31.74<tr><td>64<td>0.29<td>0.48<td>1.72<td>14.38<td>52.47<td>57.34<td>60.58<tr><td>128<td>0.38<td>0.48<td>1.63<td>16.62<td>87.06<td>101.65<td>115.06<tr><td>256<td>0.28<td>0.43<td>1.61<td>17.84<td>125.49<td>171.93<td>207.78<tr><td>512<td>0.24<td>0.30<td>1.14<td>13.42<td>161.71<td>269.10<td>414.37</table><p>可以看到：</p><ul><li>随着问题规模增加，同进程数下加速比不断增加<li>随着进程数增加，同问题规模下加速比不断减少</ul><h4 id="效率-e">效率 E</h4><p>运行效率 E=加速比 S/并行线程数。</p><table><thead><tr><th>进程数\问题规模<th>$2^{14}$<th>$2^{18}$<th>$2^{22}$<th>$2^{26}$<th>$2^{30}$<th>$2^{31}$<th>$2^{32}$<tbody><tr><td>1<td>1.00<td>1.00<td>1.00<td>1.00<td>1.00<td>1.00<td>1.00<tr><td>2<td>0.50<td>0.93<td>0.68<td>1.00<td>0.98<td>1.00<td>1.02<tr><td>4<td>0.23<td>0.24<td>0.47<td>0.95<td>0.97<td>0.99<td>1.02<tr><td>8<td>0.10<td>0.13<td>0.34<td>0.81<td>0.97<td>0.95<td>1.02<tr><td>16<td>0.05<td>0.06<td>0.17<td>0.68<td>0.96<td>0.96<td>0.96<tr><td>32<td>0.01<td>0.02<td>0.07<td>0.44<td>0.88<td>0.95<td>0.99<tr><td>64<td>0.005<td>0.008<td>0.03<td>0.22<td>0.82<td>0.90<td>0.95<tr><td>128<td>0.003<td>0.004<td>0.01<td>0.13<td>0.68<td>0.79<td>0.90<tr><td>256<td>0.001<td>0.002<td>0.006<td>0.07<td>0.49<td>0.67<td>0.81<tr><td>512<td>0.0005<td>0.0006<td>0.002<td>0.03<td>0.32<td>0.53<td>0.81</table><p>可以看到：</p><ul><li>随着问题规模增加，同进程数下效率不断增加<li>随着进程数增加，同问题规模下效率不断减少</ul><p>此外，部分数据出现了效率略大于 1 的情况，可能是由于系统运行时的「抖动」造成的，仍然在误差范围内，符合常识。</p><h3 id="源代码integralc">源代码<code>integral.c</code></h3><p>去掉<code>#define WK_SIMPSON</code>前的注释符号即可选用自适应辛普森公式求解瑕积分。</p><p>去掉<code>#define WK_P2P</code>前的注释符号即可选用点对点通信。</p><pre><code class="language-c">//#define WK_SIMPSON
//#define WK_P2P
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;mpi.h&gt;
typedef double lf;
const lf EPS = 1e-5;
#ifdef WK_SIMPSON
lf f(lf x)
{
	return exp(x) / sqrt(1 + exp(x));
}
lf simpson(lf a, lf b, lf f(lf x))
{
	if (fabs(a) &lt; EPS)
		return f((a + b) * 0.5) * (b - a);
	return (f(a) + 4 * f((a + b) * 0.5) + f(b)) * (b - a) / 6;
}
lf ask(lf a, lf b, lf f(lf x), lf e)
{
	if (e &lt; EPS)
		return simpson(a, b, f);
	lf c = (a + b) * 0.5, L = simpson(a, c, f), R = simpson(c, b, f), delta = (L + R - simpson(a, b, f)) / 15;
	return fabs(delta) &lt; e ? L + R + delta : ask(a, c, f, e * 0.5) + ask(c, b, f, e * 0.5);
}
#else
lf f(lf x)
{
	return x;
}
lf ask(lf a, lf b, lf f(lf x), lf e)
{
	lf ans = 0, fa = f(a);
	while (a &lt; b)
	{
		lf fb = f(a += e);
		ans += fa + fb;
		fa = fb;
	}
	return ans * e * 0.5;
}
#endif
int main(int argc, char **argv)
{
	MPI_Init(&amp;argc, &amp;argv);
	int id, numThreads;
	MPI_Comm_rank(MPI_COMM_WORLD, &amp;id);
	MPI_Comm_size(MPI_COMM_WORLD, &amp;numThreads);
	lf n = pow(2, atoi(argv[1])),
	   len = n / numThreads,
	   myL = id * len,
	   myAns = ask(myL, myL + len, f, 1e-2),
	   ans = myAns;
#ifdef WK_P2P
	if (!id)
	{
		for (int i = 1; i &lt; numThreads; ++i)
		{
			MPI_Recv(
				&amp;myAns,
				1,
				MPI_DOUBLE,
				i,
				0,
				MPI_COMM_WORLD,
				MPI_STATUES_IGNORE);
			ans += myAns;
		}
	}
	else
		MPI_Send(
			&amp;myAns,
			1,
			MPI_DOUBLE,
			0,
			0,
			MPI_COMM_WORLD);
#else
	MPI_Reduce(
		&amp;myAns,
		&amp;ans,
		1,
		MPI_DOUBLE,
		MPI_SUM,
		0,
		MPI_COMM_WORLD);
#endif
	if (!id)
		printf("%f with %d proces, problem size %.0f.", ans, numThreads, n);
	MPI_Finalize();
}
</code></pre><h3 id="作业脚本integralpbs">作业脚本<code>integral.pbs</code></h3><p>对于不同的核数需要不同的作业脚本，这里只给出 512 核对应的作业脚本<code>integral.pbs</code>。</p><p>这里学习了一下从 PBS 的本地变量中获得 mpiexec 的运行配置的方法。</p><pre><code class="language-bash">#PBS -N integral
#PBS -l nodes=16:ppn=32
#PBS -j oe

source /public/software/profile.d/mpi_openmpi-intel-2.1.2.sh
mpicc integral.c -o integral -std=c11 -lm
for logN in 14 18 22 26 30 31 32
do
time mpiexec -machinefile $PBS_NODEFILE ./integral $logN
done
</code></pre><h3 id="输出文件integralo1761">输出文件<code>integral.o1761</code></h3><p>对于不同的核数需要不同的输出文件，这里只给出 512 核对应输出文件<code>integral.o1761</code>。</p><p>其他核数对应的输出文件见附件</p><ul><li><code>integral.o1795</code>对应 256 核（<code>nodes=8:ppn=32</code>）<li><code>integral.o1796</code>对应 128 核（<code>nodes=4:ppn=32</code>）<li><code>integral.o1797</code>对应 64 核（<code>nodes=2:ppn=32</code>）<li><code>integral.o1798</code>对应 32 核（<code>nodes=1:ppn=32</code>）<li><code>integral.o1799</code>对应 16 核（<code>nodes=1:ppn=16</code>）<li><code>integral.o1800</code>对应 8 核（<code>nodes=1:ppn=8</code>）<li><code>integral.o1801</code>对应 4 核（<code>nodes=1:ppn=4</code>）<li><code>integral.o1802</code>对应 2 核（<code>nodes=1:ppn=2</code>）<li><code>integral.o1803</code>对应 1 核（<code>nodes=1:ppn=1</code>）</ul><pre><code class="language-bash">134218391.043055 with 512 proces, problem size 16384.
real	0m1.802s
user	0m2.328s
sys	0m6.054s
34359872522.271759 with 512 proces, problem size 262144.
real	0m1.704s
user	0m2.188s
sys	0m5.706s
8796101094338.814453 with 512 proces, problem size 4194304.
real	0m1.695s
user	0m2.281s
sys	0m5.844s
2251800146489160.500000 with 512 proces, problem size 67108864.
real	0m1.754s
user	0m4.053s
sys	0m5.900s
576461292861516288.000000 with 512 proces, problem size 1073741824.
real	0m2.210s
user	0m20.316s
sys	0m5.308s
2305845201815247872.000000 with 512 proces, problem size 2147483648.
real	0m2.626s
user	0m36.019s
sys	0m4.861s
9223215905289959424.000000 with 512 proces, problem size 4294967296.
real	0m3.478s
user	0m59.168s
sys	0m5.120s
</code></pre><h2 id="完成正则采样排序-psrs-的-mpi-算法">完成正则采样排序 PSRS 的 MPI 算法</h2><p>排序文件放在集群的 shared_dir 目录下，文件名为：psrs_data。文件采用二进制格式：头八个字节为排序数据个数(long int), 每个数据为 8 个字节。</p><p>请按要求使用 MPI 集合通信：具体要求见课件。</p><h3 id="psrsc">psrs.c</h3><p>这里遇到一个问题，MPI 数据类型选择<code>MPI_LONG_INT</code>时发现传过来的数据大小只有 4 个字节？于是使用<code>MPI_BYTE</code>类型，而将我们的数据按照比特重新计算大小并传输。</p><pre><code class="language-c">//#define WK_GEN_DATA
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mpi.h&gt;
typedef long int ll;
int sgn(ll a) { return a &lt; 0 ? -1 : a ? 1 : 0; }
int cmpll(const void *a, const void *b) { return sgn(*(ll *)a - *(ll *)b); }
int main(int argc, char **argv)
{
	int id, numThreads;
	MPI_Init(&amp;argc, &amp;argv);
	double start = MPI_Wtime();
	MPI_Comm_rank(MPI_COMM_WORLD, &amp;id);
	MPI_Comm_size(MPI_COMM_WORLD, &amp;numThreads);
#ifdef WK_GEN_DATA
	ll n = ((ll)1) &lt;&lt; atoi(argv[1]),
	   len = n / numThreads,
	   *a = (ll *)malloc(len * sizeof(ll));
#else
	ll n;
	MPI_File fh;
	MPI_File_open(
		MPI_COMM_WORLD,
		argv[1],
		MPI_MODE_RDONLY,
		MPI_INFO_NULL,
		&amp;fh);
	MPI_File_read_at_all(
		fh,
		0,
		&amp;n,
		1 * sizeof(ll), //1,
		MPI_BYTE,		//MPI_LONG_INT,
		MPI_STATUSES_IGNORE);
	ll blockSize = (n + numThreads - 1) / numThreads,
	   beg = id * blockSize,
	   end = beg + blockSize &lt; n ? beg + blockSize : n,
	   len = end - beg,
	   *a = (ll *)malloc(len * sizeof(ll));
	MPI_File_read_at_all(
		fh,
		sizeof(ll) * (1 + beg),
		a,
		len * sizeof(ll), //len,
		MPI_BYTE,		  //MPI_LONG_INT,
		MPI_STATUSES_IGNORE);
	MPI_File_close(&amp;fh);
	MPI_Barrier(MPI_COMM_WORLD);
	if (!id)
		printf("Finish reading %ld datas at %fs with %d procs.\n", n, MPI_Wtime() - start, numThreads);
#endif
	qsort(a, len, sizeof(ll), cmpll);
	//局部排序
	ll *sample = (ll *)malloc(numThreads * sizeof(ll)),
	   *sampleGather = (ll *)malloc(numThreads * numThreads * sizeof(ll));
	for (int i = 0; i &lt; numThreads; ++i)
		sample[i] = a[len / numThreads * i];

	//采样
	MPI_Gather(
		sample,
		numThreads * sizeof(ll), //numThreads,
		MPI_BYTE,				 //MPI_LONG_INT,
		sampleGather,
		numThreads * sizeof(ll), //numThreads,
		MPI_BYTE,				 //MPI_LONG_INT,
		0,
		MPI_COMM_WORLD);

	if (!id)
	{
		qsort(sampleGather, numThreads * numThreads, sizeof(ll), cmpll); //可优化为n路归并
		for (int i = 0; i &lt; numThreads; ++i)
			sample[i] = sampleGather[i * numThreads]; //获得主元
#ifndef WK_GEN_DATA
		printf("Get privot at %fs with %d procs.\n", MPI_Wtime() - start, numThreads);
#endif
	}

	MPI_Bcast(
		sample,
		numThreads * sizeof(ll), //numThreads,
		MPI_BYTE,				 //MPI_LONG_INT,
		0,
		MPI_COMM_WORLD); //分发主元

	int *sendCounts = (int *)malloc(numThreads * sizeof(int)),
		*recvCounts = (int *)malloc(numThreads * sizeof(int)),
		*sdisp = (int *)malloc(numThreads * sizeof(int)),
		*rdisp = (int *)malloc(numThreads * sizeof(int));

	for (int i = 0; i &lt; numThreads; ++i)
		sendCounts[i] = 0;

	for (int i = 0, j = 0; i &lt; len; ++i)
	{
		while (j &lt; numThreads &amp;&amp; a[i] &gt;= sample[j])
			++j;
		//++sendCounts[j - 1];
		sendCounts[j - 1] += sizeof(ll);
	}

	MPI_Alltoall( //提前通知一下节点，各个节点要准备接收多少数据
		sendCounts,
		//1 * sizeof(int),
		1,
		//MPI_BYTE,
		MPI_INT,
		recvCounts,
		//1 * sizeof(int),
		1,
		//MPI_BYTE,
		MPI_INT,
		MPI_COMM_WORLD);
#ifndef WK_GEN_DATA
	if (!id)
		printf("Send counts at %fs with %d procs.\n", MPI_Wtime() - start, numThreads);
#endif
	sdisp[0] = rdisp[0] = 0;
	for (int i = 1; i &lt; numThreads; ++i)
	{
		sdisp[i] = sendCounts[i - 1] + sdisp[i - 1];
		rdisp[i] = recvCounts[i - 1] + rdisp[i - 1];
	}

	//ll *local = (ll *)malloc((rdisp[numThreads - 1] + recvCounts[numThreads - 1]) * sizeof(ll));
	ll *local = (ll *)malloc(rdisp[numThreads - 1] + recvCounts[numThreads - 1]);

	MPI_Alltoallv(
		a,
		sendCounts,
		sdisp,
		MPI_BYTE, //MPI_LONG_INT,
		local,
		recvCounts,
		rdisp,
		MPI_BYTE, //MPI_LONG_INT,
		MPI_COMM_WORLD);
#ifndef WK_GEN_DATA
	if (!id)
		printf("Alltoallv at %fs with %d procs.\n", MPI_Wtime() - start, numThreads);
#endif
	//qsort(local, rdisp[numThreads - 1] + recvCounts[numThreads - 1], sizeof(ll), cmpll); //可优化为n路归并
	qsort(local, (rdisp[numThreads - 1] + recvCounts[numThreads - 1]) / sizeof(ll), sizeof(ll), cmpll); //可优化为n路归并

	if (!id)
		printf("Finish sort %ld elements at %fs with %d procs.\n", n, MPI_Wtime() - start, numThreads);

	free(local);
	free(sendCounts);
	free(recvCounts);
	free(sdisp);
	free(rdisp);

	free(sample);
	free(sampleGather);
	free(a);

	MPI_Finalize();
}
</code></pre><h3 id="psrspbs">psrs.pbs</h3><p>作业调度脚本，直接使用能够获得的最大计算资源（512 核）进行计算。</p><pre><code class="language-bash">#PBS -N psrs
#PBS -l nodes=16:ppn=32
#PBS -j oe

source /public/software/profile.d/mpi_openmpi-intel-2.1.2.sh
mpicc psrs.c -o psrs -std=c11
mpiexec -machinefile $PBS_NODEFILE ./psrs /public/home/shared_dir/psrs_data
</code></pre><h3 id="psrso1529">psrs.o1529</h3><p>作业脚本得到的输出文件。可以看到，这里一共使用了<code>18.124634s</code>就成功对<code>4294967295</code>个数进行了排序，其中有<code>6.403623s</code>花费在文件读入上，也就是总共花了不到十二秒就完成了排序，还是明显优于单机串行排序的。</p><pre><code class="language-bash">Finish reading 4294967295 datas at 6.403623s with 512 procs.
Get privot at 8.314104s with 512 procs.
Send counts at 8.333872s with 512 procs.
Alltoallv at 17.238057s with 512 procs.
Finish all the works at 18.124634s with 512 procs.
</code></pre><h3 id="填表-1">填表</h3><p>去掉<code>#define WK_GEN_DATA</code>前的注释，进行测试（不再从输入文件中得到数据，各进程随机生成指定问题规模规模的数据）。</p><p>此外，由于并行正则采样排序的限制，排序元素的数量至少要是进程数的平方倍。因此这里问题规模从$2^18$开始（进程数最多有$512=2^9$个）。</p><p>由于数据规模过大，进程数少的时候运行时间超过一小时被调度器<code>kill</code>了，因此对应数据没有测出运行时间和相应加速比。</p><h4 id="运行时间-t单位-s-1">运行时间 T（单位 s）</h4><p>详见下面的输出文件部分。</p><table><thead><tr><th>进程数\问题规模<th>$2^{18}$<th>$2^{22}$<th>$2^{26}$<th>$2^{30}$<th>$2^{31}$<th>$2^{32}$<tbody><tr><td>1<td>0.04<td>0.35<td>7.10<td>936.30<td>x<td>x<tr><td>2<td>0.04<td>0.23<td>3.10<td>463.53<td>x<td>x<tr><td>4<td>0.05<td>0.20<td>2.12<td>229.26<td>890.62<td>x<tr><td>8<td>0.05<td>0.18<td>1.56<td>149.69<td>592.83<td>x<tr><td>16<td>0.05<td>0.20<td>1.22<td>80.37<td>250.98<td>490.23<tr><td>32<td>0.09<td>0.22<td>0.96<td>43.30<td>176.67<td>277.68<tr><td>64<td>0.14<td>0.47<td>0.89<td>21.77<td>136.30<td>90.79<tr><td>128<td>0.21<td>0.44<td>1.13<td>17.87<td>33.21<td>44.52<tr><td>256<td>0.29<td>0.45<td>1.28<td>9.22<td>17.43<td>23.93<tr><td>512<td>0.38<td>0.57<td>1.47<td>5.10<td>8.30<td>14.47</table><h4 id="加速比-s-1">加速比 S</h4><p>加速比 S=同等规模下的串行时间/并行时间。</p><table><thead><tr><th>进程数\问题规模<th>$2^{18}$<th>$2^{22}$<th>$2^{26}$<th>$2^{30}$<th>$2^{31}$<th>$2^{32}$<tbody><tr><td>1<td>1.00<td>0.35<td>1.00<td>1.00<td>x<td>x<tr><td>2<td>1.00<td>1.52<td>2.29<td>2.02<td>x<td>x<tr><td>4<td>0.80<td>1.75<td>3.35<td>4.08<td>x<td>x<tr><td>8<td>0.80<td>1.94<td>4.55<td>6.25<td>x<td>x<tr><td>16<td>0.80<td>1.75<td>5.81<td>11.65<td>x<td>x<tr><td>32<td>0.44<td>1.59<td>7.40<td>21.62<td>x<td>x<tr><td>64<td>0.29<td>0.74<td>7.98<td>43.00<td>x<td>x<tr><td>128<td>0.19<td>0.80<td>6.28<td>52.40<td>x<td>x<tr><td>256<td>0.14<td>0.78<td>5.55<td>101.55<td>x<td>x<tr><td>512<td>0.11<td>0.61<td>4.83<td>183.58<td>x<td>x</table><h4 id="效率-e-1">效率 E</h4><p>运行效率 E=加速比 S/并行线程数。</p><table><thead><tr><th>进程数\问题规模<th>$2^{18}$<th>$2^{22}$<th>$2^{26}$<th>$2^{30}$<th>$2^{31}$<th>$2^{32}$<tbody><tr><td>1<td>1.00<td>0.35<td>1.00<td>1.00<td>x<td>x<tr><td>2<td>1.00<td>0.76<td>1.15<td>1.01<td>x<td>x<tr><td>4<td>0.20<td>0.44<td>0.84<td>1.02<td>x<td>x<tr><td>8<td>0.10<td>0.24<td>0.57<td>0.78<td>x<td>x<tr><td>16<td>0.05<td>0.11<td>0.32<td>0.73<td>x<td>x<tr><td>32<td>0.01<td>0.05<td>0.23<td>0.66<td>x<td>x<tr><td>64<td>0.005<td>0.01<td>0.12<td>0.67<td>x<td>x<tr><td>128<td>0.001<td>0.006<td>0.05<td>0.41<td>x<td>x<tr><td>256<td>0.0005<td>0.003<td>0.02<td>0.40<td>x<td>x<tr><td>512<td>0.0002<td>0.001<td>0.001<td>0.36<td>x<td>x</table></div><script repo="wu-kan/utterances-storage" src="https://utteranc.es/client.js" issue-term="url" theme="github-light" crossorigin="anonymous" async="async" ></script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" /><style> .katex-display>.katex { white-space: normal; }</style><script src="https://cdn.jsdelivr.net/combine/npm/katex@0.13.11/dist/katex.min.js,npm/katex@0.13.11/dist/contrib/auto-render.min.js" async="async" onload='renderMathInElement(document.body, { delimiters: [{left: "$$", right: "$$", display: true}, { left: "$", right: "$", display: false }, {left: "\\(", right: "\\)", display: false}, {left: "\\[", right: "\\]", display: true}]})' ></script><style> pre.language-mermaid, code.language-mermaid { display: none; } @media only screen { .mermaid { overflow: auto auto; max-width: 100%; max-height: 66.6vh; } }</style><script src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" async="async" onload=' for(let x of document.getElementsByClassName("language-mermaid")) if(x.nodeName=="CODE") { let m = document.createElement("div"); m.classList.add("mermaid"); m.textContent = x.textContent; x.parentNode.insertAdjacentElement("beforebegin", m); }' ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.css,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.css,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.css,npm/prism-themes@1.5.0/themes/prism-nord.min.css" /> <script src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/components/prism-core.min.js,npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js,npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.js,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.js" async="async" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/" onload=' for(let x of document.getElementsByClassName("content")) x.classList.add("line-numbers","match-braces"); Prism.plugins.toolbar.registerButton("select-code", function (env) { let button = document.createElement("button"); button.textContent = "select this " + env.language; button.addEventListener("click", function () { if (document.body.createTextRange) { let range = document.body.createTextRange(); range.moveToElementText(env.element); range.select(); } else if (window.getSelection) { let selection = window.getSelection(); let range = document.createRange(); range.selectNodeContents(env.element); selection.removeAllRanges(); selection.addRange(range); } }); return button; })' ></script></div><label for="sidebar-checkbox" class="sidebar-toggle"></label>
