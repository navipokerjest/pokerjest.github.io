<!DOCTYPE html><html><head><title> 正则表达式关系判定 &middot; wu-kan</title><!-- Begin Jekyll SEO tag v2.7.1 --><meta name="generator" content="Jekyll v3.9.0" /><meta property="og:title" content="正则表达式关系判定" /><meta property="og:locale" content="en_US" /><meta name="description" content="SYSU超算17级在读 水野爱 HPC 田宫例四驱车 &lt;iframe src=”https://music.163.com/outchain/player?type=0&amp;id=155059595&amp;auto=0&amp;height=32” width=100% height=52 frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” &lt;/iframe&gt;" /><meta property="og:description" content="SYSU超算17级在读 水野爱 HPC 田宫例四驱车 &lt;iframe src=”https://music.163.com/outchain/player?type=0&amp;id=155059595&amp;auto=0&amp;height=32” width=100% height=52 frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” &lt;/iframe&gt;" /><link rel="canonical" href="http://localhost:4000/2020/07/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%88%A4%E5%AE%9A/" /><meta property="og:url" content="http://localhost:4000/2020/07/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%88%A4%E5%AE%9A/" /><meta property="og:site_name" content="wu-kan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-03T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="正则表达式关系判定" /><meta name="google-site-verification" content="YIKi1rBnyUaS-DMYiluseI5kZzTwjCkTFmKkSkMZDJk" /><meta name="baidu-site-verification" content="szbTSfUGAB" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"http://localhost:4000/2020/07/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%88%A4%E5%AE%9A/","datePublished":"2020-07-03T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/07/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%88%A4%E5%AE%9A/"},"headline":"正则表达式关系判定","description":"SYSU超算17级在读 水野爱 HPC 田宫例四驱车 &lt;iframe src=”https://music.163.com/outchain/player?type=0&amp;id=155059595&amp;auto=0&amp;height=32” width=100% height=52 frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” &lt;/iframe&gt;","dateModified":"2020-07-03T00:00:00+08:00","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" /><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="alternate" href="/feed.xml" title="RSS" type="application/rss+xml" /><link rel="apple-touch-icon-precomposed" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" /><link rel="shortcut icon" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=32" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/poole/lanyon@v1.1.0/public/css/poole.min.css,gh/poole/lanyon@v1.1.0/public/css/lanyon.min.css,gh/poole/lanyon@v1.1.0/public/css/syntax.min.css" /> <script async="async" src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/js/all.min.js" ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dreamer-Paul/Pio@2.4/static/pio.min.css" /><style> @media only print { .pio-container { display: none; } }</style><script async="async" src="https://cdn.jsdelivr.net/combine/gh/Dreamer-Paul/Pio@2.4/static/l2d.min.js,gh/Dreamer-Paul/Pio@2.4/static/pio.min.js" onload=' let pio_container = document.createElement("div"); pio_container.classList.add("pio-container"); pio_container.classList.add("right"); pio_container.style.bottom = "-2rem"; pio_container.style.zIndex = "1"; document.body.insertAdjacentElement("beforeend", pio_container); let pio_action = document.createElement("div"); pio_action.classList.add("pio-action"); pio_container.insertAdjacentElement("beforeend", pio_action); let pio_canvas = document.createElement("canvas"); pio_canvas.id = "pio"; pio_canvas.style.width = "14rem"; pio_canvas.width = "600"; pio_canvas.height = "800"; pio_container.insertAdjacentElement("beforeend", pio_canvas); let pio = new Paul_Pio({ "mode": "fixed", "hidden": true, "night": "for(let i=7; i<16; ++i) if(document.body.classList.contains(`theme-base-0`+i.toString(16))) { document.body.classList.remove(`theme-base-0`+i.toString(16)); document.body.classList.add(`theme-base-0`+((i-6)%9+7).toString(16)); break; }", "content": { "link": ["https:\/\/jekyll-theme-WuK.wu-kan.cn"], "skin": ["要换成我的朋友吗？", "让她放个假吧~"], "hidden": true, "custom": [{ "selector": "a", "type": "link", }, { "selector": ".sidebar-toggle", "text": "打开侧边栏叭~" }, { "selector": ".effect-info", "text": "哇，你发现了什么！" }, { "selector": "#sidebar-search-input", "text": "想搜索什么呢？很多干货哦！" }, { "selector": "#toc", "text": "这是目录~" }, { "selector": ".page-title", "text": "这是标题~" }, { "selector": ".v", "text": "评论没有审核，要对自己的发言负责哦~" }] }, "model": [ "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/33/model.2018.bls-winter.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/platelet-2/model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/xiaomai/xiaomai.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/mashiro/seifuku.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/Violet/14.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/Kobayaxi/Kobayaxi.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/mikoto/mikoto.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/uiharu/uiharu.model.json"] });' ></script> <script src='https://zz.bdstatic.com/linksubmit/push.js' async="async" ></script><style> .wrap { transition-property: width,background-size,transform; transition-duration: .3s; transition-timing-function: ease-in-out; min-height: 100%; display: inline-block; background-size: 100% auto; background-position: 0% 0%; background-repeat: no-repeat; background-attachment: fixed; background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/74559485_p1.webp); } @media (min-aspect-ratio: 2400/1850) { .wrap { background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/71932901_p0.webp); } } .sidebar-overlay #sidebar-checkbox:checked ~ .wrap { width: calc(100% - 14rem); background-size: calc(100% - 14rem) auto; transform: translateX(14rem); } .layout-reverse.sidebar-overlay #sidebar-checkbox:checked ~ .wrap { transform: translateX(0); }</style><style> .sidebar, html, h1, h2, h3, h4, h5, h6 { font-family: "Courier New", "Courier", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Microsoft YaHei Light", "Microsoft JhengHei", monospace; }</style><style> td, th { padding: 0px; border: 0px; } table { border: 0px; } table tbody { display: block; overflow: scroll; } table thead, tbody tr { display: table; table-layout: fixed; width: 100%; }</style><style> img { display: inline-block; margin: 0; }</style><style> ::-webkit-scrollbar { width: 3px; height: 3px; } ::-webkit-scrollbar-thumb { background-image: linear-gradient(45deg, Cyan 0%, Magenta 50%, Yellow 100%); }</style><style> ::selection { color: White; background: Black; }</style><body class="theme-base-0d layout-reverse sidebar-overlay"> <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. --> <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" /> <!-- Toggleable sidebar --><div class="sidebar" id="sidebar"><div class="sidebar-item"><div class="effect effect-right_to_left"> <img class="effect-img" src="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" alt="img" /><div class="effect-info"> SYSU超算17级在读<br/> 水野爱<br/> HPC<br/> 田宫例四驱车<br/> <a href="mailto:i@wu-kan.cn"> <i class="fas fa-envelope"></i> </a> <a href="https://github.com/wu-kan"> <i class="fab fa-github"></i> </a> <a href="https://codeforces.com/profile/WuK"> <i class="fas fa-chart-bar"></i> </a> <a href="https://vjudge.net/user/WuK"> <i class="fas fa-smile"></i> </a> <a href="https://www.zhihu.com/people/wu.kan/activities"> <i class="fab fa-zhihu"></i> </a> <iframe src="https://music.163.com/outchain/player?type=0&id=155059595&auto=0&height=32" width=100% height=52 frameborder="no" border="0" marginwidth="0" marginheight="0" ></iframe></div></div></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/"> <i class="fas fa-home fa-fw"></i> 首页 </a> <a class="sidebar-nav-item" href="/comments/"> <i class="fas fa-comments fa-fw"></i> 留言 </a> <a class="sidebar-nav-item" href="/tags/"> <i class="fas fa-tags fa-fw"></i> 标签 </a> <a class="sidebar-nav-item" href="/archive/"> <i class="fas fa-archive fa-fw"></i> 归档 </a> <a class="sidebar-nav-item" href="/merger/"> <i class="fas fa-coffee fa-fw"></i> 打赏 </a></nav><div class="sidebar-item"><style> #sidebar-search-input { background: none; border: none; color: White; width: 100%; } #sidebar-search-results-container { overflow: auto auto; max-height: 66.6vh; }</style><input id="sidebar-search-input" placeholder="搜索博文" /><ol id="sidebar-search-results-container" ></ol><script src='https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.9.1' async='async' onload=' SimpleJekyllSearch({ json: "/assets/simple-jekyll-search/search.json", searchInput: document.getElementById("sidebar-search-input"), resultsContainer: document.getElementById("sidebar-search-results-container"), searchResultTemplate: `<li><a href="{url}">{title}</a>`, limit: 999, fuzzy: true })' ></script><style> #toc { overflow: auto auto; max-height: 66.6vh; }</style><ol id="toc"><li><a href="#description">Description</a><li><a href="#input">Input</a><li><a href="#output">Output</a><li><a href="#%E5%AE%9E%E9%AA%8C%E5%8E%9F%E7%90%86">实验原理</a><ol><li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%88%90%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式转成中缀表达式</a><li><a href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%88%90%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">中缀表达式转成后缀表达式</a><li><a href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%88%90%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA">后缀表达式转成非确定有限自动机</a><ol><li><a href="#%E9%81%87%E5%88%B0%E5%AD%97%E7%AC%A6">遇到字符</a><li><a href="#%E9%81%87%E5%88%B0-">遇到 *</a><li><a href="#%E9%81%87%E5%88%B0--1">遇到 ?</a><li><a href="#%E9%81%87%E5%88%B0--2">遇到 +</a><li><a href="#%E9%81%87%E5%88%B0--3">遇到 &amp;</a><li><a href="#%E9%81%87%E5%88%B0--4">遇到 |</a></ol><li><a href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E8%BD%AC%E6%88%90%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA">非确定有限自动机转成确定有限自动机</a><li><a href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%85%B3%E7%B3%BB">判断两个确定有限自动机的关系</a></ol><li><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">实验过程</a><ol><li><a href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-inputtxt">样例输入 input.txt</a><li><a href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-outputtxt">样例输出 output.txt</a><li><a href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE-testdatain">测试数据 testdata.in</a><li><a href="#%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88-testdataout">测试答案 testdata.out</a><li><a href="#%E6%BA%90%E4%BB%A3%E7%A0%81-regex_cmpcpp">源代码 regex_cmp.cpp</a></ol></ol><style> .sidebar-checkbox { display: none; } .sidebar-toggle { position: fixed; }</style><style> .sidebar { overflow: scroll; min-height: 101%; }</style><style> .effect { margin: 1rem; perspective: 900px; } .effect-info { text-align: center; position: absolute; top: 0; transform-style: preserve-3d; } .effect-img { z-index: 11; width: 100%; height: 100%; position: relative; transition: all 0.5s ease-in-out; } .effect-img:before { position: absolute; display: block; } .effect-right_to_left .effect-img { transform-origin: 0% 50%; } .effect-right_to_left:hover .effect-img { transform: rotate3d(0, 1, 0, -180deg); }</style><div> <i class="fas fa-cog fa-spin fa-fw"></i> <span id="run_time_day"> <i class="fas fa-spinner fa-pulse"></i> </span>天 <span id="run_time_hour"> <i class="fas fa-spinner fa-pulse"></i> </span>时 <span id="run_time_minute"> <i class="fas fa-spinner fa-pulse"></i> </span>分 <span id="run_time_second"> <i class="fas fa-spinner fa-pulse"></i> </span>秒 <script> setInterval(function (d,h,m,s,b) { function setzero(i) { return i < 10 ? "0" + i : i; } let BirthDay = new Date(b); let today = new Date(); let timeold = (today.getTime() - BirthDay.getTime()); let sectimeold = timeold / 1000; let secondsold = Math.floor(sectimeold); let msPerDay = 24 * 60 * 60 * 1000; let e_daysold = timeold / msPerDay; let daysold = Math.floor(e_daysold); let e_hrsold = (e_daysold - daysold) * 24; let hrsold = Math.floor(e_hrsold); let e_minsold = (e_hrsold - hrsold) * 60; let minsold = Math.floor((e_hrsold - hrsold) * 60); let seconds = Math.floor((e_minsold - minsold) * 60); d.textContent = daysold; h.textContent = setzero(hrsold); m.textContent = setzero(minsold); s.textContent = setzero(seconds); }, 1000, document.getElementById("run_time_day"), document.getElementById("run_time_hour"), document.getElementById("run_time_minute"), document.getElementById("run_time_second"), "10/04/2017 11:03:56")// 这是我第一篇CSDN博客的时间 </script></div><div><div> <i class="fas fa-eye fa-fw"></i> <span id="busuanzi_value_page_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>次</div><div> <i class="fas fa-paw fa-fw"></i> <span id="busuanzi_value_site_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>枚</div><div> <i class="fas fa-user-friends fa-fw"></i> <span id="busuanzi_value_site_uv"> <i class="fas fa-spinner fa-pulse"></i> </span>人</div><script src='https://cdn.jsdelivr.net/npm/busuanzi@2.3.0' async='async' ></script></div><div> <i class="fas fa-thumbs-up fa-fw"></i> <a href="https://jekyll-theme-WuK.wu-kan.cn"> jekyll-theme-WuK </a></div><div> <i class="fas fa-copyright fa-fw"></i> 2017-2021 WuK</div><div> <i class="fas fa-info-circle fa-fw"></i> <a href="http://beian.miit.gov.cn"> 粤ICP备 20024947号 </a></div><div> <img src="https://i.loli.net/2021/03/17/Y47tDZTrcy2xwRa.png" class="fa-fw"></img> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=34070202000407"> 皖公网安备 34070202000407号 </a></div></div></div><!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --><div class="wrap"><style> @media only screen { pre { max-height: 66.6vh; overflow: auto; } }</style><style> .container { min-width: 66.6%; } @media only print { .container { min-width: 100%; } }</style><style> .container.content { padding: 2rem; box-shadow: 0 0 2rem rgba(255,255,255,0.9); background-color: rgba(255,255,255,0.9); animation-duration: 2s; animation-name: fadeIn; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }</style><div class="container content"><div class="page"><h1 class="page-title">正则表达式关系判定</h1><div class="post"> <span class="post-date"> <i class="fas fa-calendar-day fa-fw"></i> 03 Jul 2020 <i class="fas fa-file-word fa-fw"></i> 12992字 <i class="fas fa-clock fa-fw"></i> 44分 <br/> <i class="fas fa-coffee fa-fw"></i> <a href="/merger/">如果这篇博客帮助到你，可以请我喝一杯咖啡~</a> <br/> <i class="fab fa-creative-commons-by fa-fw"></i> <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="license"> CC BY 4.0 </a> （除特别声明或转载文章外） </span><p><img src="data:image/webp;base64,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" alt="成绩" /></p><h2 id="description">Description</h2><p>对于两个正则表达式 r 和 s，判断这两个正则表达式的关系。正则表达式的关系有 4 种：</p><ol><li>r 和 s 等价，即 r 描述的语言和 s 描述的语言相等；<li>r 描述的语言是 s 描述的语言的真子集；<li>s 描述的语言是 r 描述的语言的真子集；<li>非上述情况。</ol><p>输入的正则表达式只包含小写字母<code>a</code>-<code>z</code>, <code>|</code>, <code>*</code>, <code>?</code>, <code>+</code>, <code>E</code>, <code>(</code>, <code>)</code>。其中，<code>a</code>-<code>z</code>是所描述语言字符集中的字符，<code>E</code> 表示 epsilon（空串），其它符号含义和教材相同。</p><p>请编写一个 C++ 程序实现上述功能。</p><h2 id="input">Input</h2><p>第一行是测试数组的组数 T。</p><p>接下来的 T 行，每行是两个正则表达式 r 和 s，每个正则表达式只包含 <code>a</code>-<code>z</code>, <code>|</code>, <code>\*</code>, <code>?</code>, <code>+</code>, <code>E</code>, <code>(</code>, <code>)</code>。两个正则表达式之间用一个空格隔开。</p><h2 id="output">Output</h2><p>输出有 T 行。对于每组数据，如果 r 和 s 等价，输出 <code>=</code>；如果 r 是 s 的真子集，输出 <code>&lt;</code>；如果 s 是 r 的真子集，输出 <code>&gt;</code>；非上述情况，输出 <code>!</code>。</p><h2 id="实验原理">实验原理</h2><p>要判断两个正则表达式的关系，我有如下的思路：</p><ol><li>正则表达式转成中缀表达式<li>中缀表达式转成后缀表达式<li>后缀表达式转成非确定有限自动机<li>非确定有限自动机转成确定有限自动机<li>判断两个确定有限自动机的关系</ol><pre><code class="language-mermaid">flowchart TB
subgraph 正则表达式转成中缀表达式
正则表达式R
正则表达式S
end
subgraph 中缀表达式转成后缀表达式
中缀表达式R
中缀表达式S
end
subgraph 后缀表达式转成非确定有限自动机
后缀表达式R
后缀表达式S
end
subgraph 非确定有限自动机转成确定有限自动机
非确定有限自动机R
非确定有限自动机S
end
subgraph 判断两个确定有限自动机的关系
确定有限自动机R
确定有限自动机S
end
正则表达式R--&gt;中缀表达式R
中缀表达式R--&gt;后缀表达式R
后缀表达式R--&gt;非确定有限自动机R
非确定有限自动机R--&gt;确定有限自动机R
正则表达式S--&gt;中缀表达式S
中缀表达式S--&gt;后缀表达式S
后缀表达式S--&gt;非确定有限自动机S
非确定有限自动机S--&gt;确定有限自动机S
确定有限自动机R--是否包含--&gt;确定有限自动机S
确定有限自动机S--是否包含--&gt;确定有限自动机R
</code></pre><p>算法的大致流程如上图，接下来我详细介绍每一部分的算法。</p><h3 id="正则表达式转成中缀表达式">正则表达式转成中缀表达式</h3><p>这一步主要将正则表达式中省略的连接运算符（<code>&amp;</code>，即 cat）加上，方便计算机运算。需要添加 <code>&amp;</code> 的有六种情况：</p><ol><li>两个字符相连，如 <code>aa</code><li>字符和左括号相连，如 <code>a(</code><li>单目运算符和字符相连，如 <code>*a</code><li>单目运算符和左括号相连，如 <code>*(</code><li>右括号和字符相连，如<code>)a</code><li>右左括号相连，如 <code>)(</code></ol><p>总结起来就是：当第一位是字符、单目运算符或右括号，且第二位为字符或左括号时，需要在他们中间加一个连接运算符。于是很容易得到下面的代码。</p><pre><code class="language-cpp">string regex_to_infix(string s)
{
	for (int i = 0; i + 1 &lt; s.size(); ++i)
		if (isalpha(s[i]) || s[i] == '?' || s[i] == '+' || s[i] == '*' || s[i] == ')')
			if (isalpha(s[i + 1]) || s[i + 1] == '(')
				s.insert(i + 1, "&amp;");
	return s;
}
</code></pre><p>以表达式<code>(a|b)*abb</code>为例，预处理后的表达式为：<code>(a|b)*&amp;a&amp;b&amp;b</code>。要注意，此处运算符的优先级别从高到低依次为：</p><ol><li>单目运算符 <code>?</code>、<code>+</code>、<code>*</code><li>连接运算符 <code>&amp;</code><li>或运算符 <code>|</code></ol><h3 id="中缀表达式转成后缀表达式">中缀表达式转成后缀表达式</h3><p><a href="https://wu-kan.cn/_posts/2020-05-26-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80">之前的实验</a> 里已经做过中缀转后缀的程序了，稍作修改就可以用在本程序中。转换过程中用到一个运算符栈，具体过程如下:</p><ol><li>如果遇到字符，直接将其输出。<li>如果遇到运算符：<ul><li>遇到左括号 <code>(</code> 直接压入栈中；<li>遇到右括号 <code>)</code> 重复将栈里的运算符弹出直到遇到 <code>(</code>，将 <code>(</code> 弹栈但不输出；<li>遇到其他运算符：<ul><li>如果栈为空，直接将运算符压入栈中；<li>如果栈不为空，弹出栈中优先级大于等于当前运算符的运算符并输出，再将当前运算符入栈。</ul></ul></ol><p>当输入串读取完之后，如果栈不为空，则将栈中元素依次出栈并输出。</p><pre><code class="language-cpp">string infix_to_suffix(const string &amp;s)
{
	string str, stak;
	static const unordered_map&lt;char, int&gt; priority{
		{'?', 3},
		{'+', 3},
		{'*', 3},
		{'&amp;', 2},
		{'|', 1},
		{'(', 0}};
	for (int i = 0; i &lt; s.size(); ++i)
	{
		if (isalpha(s[i]))
			str.push_back(s[i]);
		else if (s[i] == ')')
		{
			while (stak.back() != '(')
			{
				str.push_back(stak.back());
				stak.pop_back();
			}
			stak.pop_back();
		}
		else if (s[i] == '(')
			stak.push_back(s[i]);
		else
		{
			while (!stak.empty() &amp;&amp; priority.at(stak.back()) &gt;= priority.at(s[i]))
			{
				str.push_back(stak.back());
				stak.pop_back();
			}
			stak.push_back(s[i]);
		}
	}
	str.insert(str.end(), stak.rbegin(), stak.rend());
	return str;
}
</code></pre><h3 id="后缀表达式转成非确定有限自动机">后缀表达式转成非确定有限自动机</h3><p>我认为这一步是本次实验的核心。我设计了一个图结构于存储非确定有限自动机，其包含下述内容：</p><ol><li>边集 <code>e</code>，其中每条<strong>有向</strong>边包含<ul><li>起点 <code>first</code><li>终点 <code>second</code><li>迁移字符 <code>ch</code></ul><li>点集 <code>v</code>，其中每个顶点包含<ul><li>出边表 <code>o</code>，保存每条以当前顶点为起点的边的序号<li>是否为接收状态 <code>isAccepted</code></ul><li>增加一条边 <code>void add(const Edge &amp;ed);</code><ul><li>当加入边的顶点大小超过当前点集大小的时候会自动扩张</ul><li>计算一个图上顶点集合的闭包 <code>vector&lt;int&gt; closure(vector&lt;int&gt; se) const;</code><ul><li>后续 NFA 转 DFA 时会用到</ul><li>计算一个集合的 a_move <code>vector&lt;int&gt; a_move(const vector&lt;int&gt; &amp;se, char a) const;</code><ul><li>后续 NFA 转 DFA 时会用到</ul></ol><pre><code class="language-cpp">struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o;
		int isAccepted;
		Vertex() : isAccepted(0), o(0) {}
	};
	struct Edge
	{
		int first, second;
		char ch;
	};
	vector&lt;Vertex&gt; v;
	vector&lt;Edge&gt; e;
	Graph(int n = 0) : v(n) {}
	void add(const Edge &amp;ed);
	vector&lt;int&gt; closure(vector&lt;int&gt; se) const;
	vector&lt;int&gt; a_move(const vector&lt;int&gt; &amp;se, char a) const;
};
</code></pre><p>转换过程中要用到一个保存<strong>顶点对</strong>的栈。按顺序读取后缀表达式，每次读取一个字符，然后根据读取的不同字符，按照不同策略更新当前的图，详见下文。最后栈顶的顶点对 <code>{fi, se}</code> 就是所得 NFA 的初始状态和唯一接受状态；为方便起见，我又按照如下方式连边：</p><pre><code class="language-mermaid">flowchart LR
0--E--&gt;fi
fi-.-&gt;se
se--E--&gt;1
</code></pre><p>这样所得到的 NFA 一定是以状态 0 作为初始状态，状态 1 作为唯一接收状态。</p><h4 id="遇到字符">遇到字符</h4><p>如果遇到字符（此处用<code>a</code>代替），则在图上新建两个顶点 <code>fi</code>、<code>se</code>，在他们之间连一条迁移字符为 <code>a</code> 的边，如下图所示。</p><pre><code class="language-mermaid">flowchart LR
fi--a--&gt;se
</code></pre><p>然后将顶点对 <code>{fi, se}</code> 压栈。</p><pre><code class="language-cpp">int fi = nfa.v.size(),
	se = nfa.v.size() + 1;
nfa.add({fi, se, s[i]});
stak.push_back({fi, se});
</code></pre><h4 id="遇到-">遇到 <code>*</code></h4><p>如果遇到闭包运算符 <code>*</code>，则在图上新建两个顶点 <code>fi</code>、<code>se</code>，从栈中弹出一个顶点对 <code>{fi1, se1}</code>，按照如下方式连边（其中<code>fi1</code>到<code>se1</code>的边已经在之前连过了，无需重连）：</p><pre><code class="language-mermaid">flowchart LR
fi--E--&gt;se
fi--E--&gt;fi1
fi1-.-&gt;se1
se1--E--&gt;fi
</code></pre><p>然后将顶点对 <code>{fi, se}</code> 压栈。</p><pre><code class="language-cpp">int fi = nfa.v.size(),
	se = nfa.v.size() + 1,
	fi1 = stak.back().first,
	se1 = stak.back().second;
stak.back() = {fi, se};
nfa.add({fi, se, 'E'});
nfa.add({fi, fi1, 'E'});
nfa.add({se1, fi, 'E'});
</code></pre><h4 id="遇到--1">遇到 <code>?</code></h4><p>虽然可以直接把正则表达式中 <code>a?</code> 转换成 <code>E|a</code>，但是在前缀表达式转中缀表达式过程中做转换有些复杂，因此这一步放在创建自动机的过程中。</p><p>在图上新建两个顶点 <code>fi</code>、<code>se</code>，从栈中弹出一个顶点对 <code>{fi1, se1}</code>，按照如下方式连边（其中<code>fi1</code>到<code>se1</code>的边已经在之前连过了，无需重连）：</p><pre><code class="language-mermaid">flowchart LR
fi--E--&gt;se
fi--E--&gt;fi1
fi1-.-&gt;se1
se1--E--&gt;se
</code></pre><p>然后将顶点对 <code>{fi, se}</code> 压栈。</p><pre><code class="language-cpp">int fi = nfa.v.size(),
	se = nfa.v.size() + 1,
	fi1 = stak.back().first,
	se1 = stak.back().second;
stak.back() = {fi, se};
nfa.add({fi, se, 'E'});
nfa.add({fi, fi1, 'E'});
nfa.add({se1, se, 'E'});
</code></pre><h4 id="遇到--2">遇到 <code>+</code></h4><p>虽然可以直接把正则表达式中 <code>a+</code> 转换成 <code>aa*</code>，但是在前缀表达式转中缀表达式过程中做转换有些复杂，因此这一步放在创建自动机的过程中。</p><p>不需要创建新节点，直接从栈中弹出一个顶点对 <code>{fi, se}</code>，按照如下方式连边（其中一条边已经在之前连过了，无需重连）：</p><pre><code class="language-mermaid">flowchart LR
fi-.-&gt;se
se--E--&gt;fi
</code></pre><p>然后将顶点对 <code>{fi, se}</code> 重新压栈。</p><pre><code class="language-cpp">int fi1 = stak.back().first,
	se1 = stak.back().second;
nfa.add({se1, fi1, 'E'});
</code></pre><h4 id="遇到--3">遇到 <code>&amp;</code></h4><p>不需要创建新节点，直接从栈中弹出两个顶点对 <code>{fi1, se1}</code>、<code>{fi2, se2}</code>，按照如下方式连边（其中两条边已经在之前连过了，无需重连）：</p><pre><code class="language-mermaid">flowchart LR
fi1-.-&gt;se1
fi2-.-&gt;se2
se1--E--&gt;fi2
</code></pre><p>然后将顶点对 <code>{fi1, se2}</code> 重新压栈。</p><pre><code class="language-cpp">int fi2 = stak.back().first,
	se2 = stak.back().second;
stak.pop_back();
int fi1 = stak.back().first,
	se1 = stak.back().second;
stak.back().second = se2;
nfa.add({se1, fi2, 'E'});
</code></pre><h4 id="遇到--4">遇到 <code>|</code></h4><p>在图上新建两个顶点 <code>fi</code>、<code>se</code>，从栈中弹出两个顶点对 <code>{fi1, se1}</code>、<code>{fi2, se2}</code>，按照如下方式连边（其中两条边已经在之前连过了，无需重连）：</p><pre><code class="language-mermaid">flowchart LR
fi1-.-&gt;se1
fi2-.-&gt;se2
fi--E--&gt;fi1
fi--E--&gt;fi2
se1--E--&gt;se
se2--E--&gt;se
</code></pre><p>然后将顶点对 <code>{fi, se}</code> 重新压栈。</p><pre><code class="language-cpp">int fi2 = stak.back().first,
	se2 = stak.back().second;
stak.pop_back();
int fi = nfa.v.size(),
	se = nfa.v.size() + 1,
	fi1 = stak.back().first,
se1 = stak.back().second;
stak.back() = {fi, se};
nfa.add({fi, fi1, 'E'});
nfa.add({fi, fi2, 'E'});
nfa.add({se1, se, 'E'});
nfa.add({se2, se, 'E'});
</code></pre><h3 id="非确定有限自动机转成确定有限自动机">非确定有限自动机转成确定有限自动机</h3><p>此处使用了课本上的算法，其算法如下：</p><ol><li>一开始 <code>d_state</code> 中只有一个状态 <code>nfa.closure({0})</code>，且无标记<li>选择 <code>d_state</code> 中一个无标记的状态 <code>T</code><li>给 <code>T</code> 打标记<li>对于每个输入字符 <code>a</code><ol><li>计算 <code>U = nfa.closure(nfa.a_move(se, a))</code><li>如果 <code>U</code> 不在 <code>d_state</code> 中，将 <code>U</code> 加入 <code>d_state</code> 且不打标记<li>建立转移状态 <code>{T, U, a}</code></ol><li>如果 <code>d_state</code> 中存在一个无标记的状态返回第二步，否则算法结束</ol><p>其中，计算闭包和 a_move 均只要在图上遍历一下即可，此处不再详述。</p><pre><code class="language-cpp">Graph nfa_to_dfa(const Graph &amp;nfa)
{
	struct ID : map&lt;vector&lt;int&gt;, int&gt;
	{
		int ask(const vector&lt;int&gt; &amp;v)
		{
			if (count(v))
				return at(v);
			int s = size();
			return insert({v, s}), s;
		}
	} d_state;
	Graph dfa;
	for (vector&lt;vector&lt;int&gt;&gt; stak(1, nfa.closure({0})); !stak.empty();)
	{
		vector&lt;int&gt; se = stak.back();
		stak.pop_back();
		int id = d_state.ask(se);
		for (char a = 'a'; a &lt;= 'z'; ++a)
		{
			vector&lt;int&gt; se2 = nfa.closure(nfa.a_move(se, a));
			if (!d_state.count(se2))
				stak.push_back(se2);
			dfa.add({id, d_state.ask(se2), a});
		}
	}
	for (ID::iterator it = d_state.begin(); it != d_state.end(); ++it)
		if (find(it-&gt;first.begin(), it-&gt;first.end(), 1) != it-&gt;first.end())
			dfa.v[it-&gt;second].isAccepted = 1;
	return dfa;
}
</code></pre><h3 id="判断两个确定有限自动机的关系">判断两个确定有限自动机的关系</h3><p>这一步才是主要实现实验要求的部分，实际上这里只要实现一个检查“包含”关系的函数即可，然后按照</p><ol><li>如果 r 包含 s 且 s 包含 r，则 r 和 s 等价<li>如果 r 不包含 s 且 s 包含 r，则 r 描述的语言是 s 描述的语言的真子集<li>如果 r 包含 s 且 s 不包含 r，则 s 描述的语言是 r 描述的语言的真子集<li>非上述情况</ol><p>得到答案。而要判断有限自动机的包含关系，可以通过一次搜索遍历完成。</p><pre><code class="language-cpp">int contain(const Graph &amp;lhs, const Graph &amp;rhs)
{
	vector&lt;vector&lt;int&gt;&gt; vis(lhs.v.size(), vector&lt;int&gt;(rhs.v.size(), 0));
	for (vector&lt;pair&lt;int, int&gt;&gt; q(vis[0][0] = 1, {0, 0}); !q.empty();)
	{
		int xl = q.back().first,
			xr = q.back().second;
		q.pop_back();
		if (lhs.v[xl].isAccepted &lt; rhs.v[xr].isAccepted)
			return 0;
		for (int i = 0; i &lt; lhs.v[xl].o.size(); ++i)
		{
			int yl = lhs.e[lhs.v[xl].o[i]].second,
				yr = rhs.e[rhs.v[xr].o[i]].second;
			if (!vis[yl][yr])
				vis[yl][yr] = 1, q.push_back({yl, yr});
		}
	}
	return 1;
}
</code></pre><p>这段代码同时经过了 <a href="https://vjudge.net/solution/26302640">History of Languages</a> 这道题目的测试，可以验证它的正确性！</p><h2 id="实验过程">实验过程</h2><p>我的实验环境是：</p><ul><li>Intel(R) Core(TM) i7-6567U CPU @3.30GHZ 3.31GHz<li>8.00GB RAM<li>Windows 10 2004 19041.264, 64-bit<ul><li>Visual Studio Code 1.47.0<ul><li>Remote - WSL 0.44.4：配合 WSL，在 Windows 上获得 Linux 接近原生环境的体验。</ul><li>Windows Subsystem for Linux [Ubuntu 20.04 LTS]：WSL 是以软件的形式运行在 Windows 下的 Linux 子系统，是近些年微软推出来的新工具，可以在 Windows 系统上原生运行 Linux。<ul><li>gcc version 9.3.0 (Ubuntu 9.3.0-10ubuntu2)</ul></ul></ul><p>在 Linux 终端依次执行下述指令可以将我的代码 <code>regex_cmp.cpp</code> 编译成可执行文件 <code>regex_cmp</code>。然后运行这个程序并计时，将输入重定向到 <code>input.txt</code>，将输出重定向到 <code>output.txt</code>。</p><pre><code class="language-bash">$ g++ -std=c++11 -O3 -o regex_cmp regex_cmp.cpp
$ time ./regex_cmp &lt; input.txt &gt; output.txt

real    0m0.010s
user    0m0.000s
sys     0m0.000s
</code></pre><p>可以看到，在我的机器上，十组测试数据只花费了十毫秒左右的时间就全部计算完毕，运行效率还是非常高的。</p><h3 id="样例输入-inputtxt">样例输入 <code>input.txt</code></h3><p>这里我构造了十组测试数据。前六组测试数据分别用于检验我的程序能不能够正确处理 <code>?</code>、<code>+</code>、<code>*</code>、<code>&amp;</code>（正则表达式中省略了连接运算符）、<code>|</code>、<code>E</code>（空集）；第七到第十组数据是我构造的复杂一点的例子，其中第十组数据识别的语言也是之前作业写过的“<a href="https://wu-kan.cn/_posts/2020-04-28-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BA%8C/#%E8%AE%BE%E6%9C%89%E4%B8%80%E9%97%A8%E5%B0%8F%E5%B0%8F%E8%AF%AD%E8%A8%80%E4%BB%85%E5%90%AB-zo%E6%96%9C%E6%9D%A03-%E4%B8%AA%E7%AC%A6%E5%8F%B7%E8%AF%A5%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E9%87%8A%E4%BB%A5%E4%B8%80%E4%B8%AAo-%E4%B8%BA%E5%BC%80%E5%A7%8B%E6%A0%87%E8%AE%B0%E4%BB%A5%E6%AD%A4%E5%90%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-o%E4%B8%BA%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0">小小语言</a>”（将原字符集中的 <code>/</code> 换成 <code>a</code>）。</p><pre><code class="language-bash">10
a a?
a a+
a a*
a ab
a a|b
a* (a|E)*
a(a|b)* a(ab)?+b
a(a|b)* a(ab)*b
a(ab)*b a(a|b)*ab
ao(o*z|a)*o+a aoa*(za*|o)*oa
</code></pre><h3 id="样例输出-outputtxt">样例输出 <code>output.txt</code></h3><p>容易手动验证这里结果的正确性。</p><pre><code class="language-bash">&lt;
&lt;
&lt;
!
&lt;
=
&gt;
&gt;
!
=
</code></pre><h3 id="测试数据-testdatain">测试数据 <code>testdata.in</code></h3><p>这组数据是老师提供的，当然我的结果也是正确的。</p><pre><code class="language-bash">5
((E|a)b*)* (a|b)*
b*a*b?a* b*a*ba*|b*a*
b*a*b?a* (b*|a*)(b|E)a*
(c|d)*c(c|d)(c|d) (c|d)*d(c|d)(c|d)
x+y+z+ x*y*z*
</code></pre><h3 id="测试答案-testdataout">测试答案 <code>testdata.out</code></h3><pre><code class="language-bash">=
=
&gt;
!
&lt;
</code></pre><h3 id="源代码-regex_cmpcpp">源代码 <code>regex_cmp.cpp</code></h3><p>得益于（自认为）非常不错的数据封装，此处仅用了<strong>不到 240 行</strong>代码（且未压行）就实现了所有功能！（<a href="https://github.com/GgBondXiang/RexToMinDFA">网上一些实现</a> 仅将正则表达式转成自动机就用了近一千行代码）</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct Graph
{
	struct Vertex
	{
		vector&lt;int&gt; o;
		int isAccepted;
		Vertex() : isAccepted(0), o(0) {}
	};
	struct Edge
	{
		int first, second;
		char ch;
	};
	vector&lt;Vertex&gt; v;
	vector&lt;Edge&gt; e;
	Graph(int n = 0) : v(n) {}
	void add(const Edge &amp;ed)
	{
		if (v.size() &lt; max(ed.first, ed.second) + 1)
			v.resize(max(ed.first, ed.second) + 1);
		v[ed.first].o.push_back(e.size());
		e.push_back(ed);
	}
	vector&lt;int&gt; closure(vector&lt;int&gt; se) const
	{
		vector&lt;int&gt; vis(v.size(), 0);
		while (!se.empty())
		{
			int u = se.back();
			se.pop_back();
			vis[u] = 1;
			for (int i = 0, k; i &lt; v[u].o.size(); ++i)
				if (k = v[u].o[i], !vis[e[k].second] &amp;&amp; e[k].ch == 'E')
				{
					vis[e[k].second] = 1;
					se.push_back(e[k].second);
				}
		}
		for (int i = 0; i &lt; vis.size(); ++i)
			if (vis[i])
				se.push_back(i);
		return se;
	}
	vector&lt;int&gt; a_move(const vector&lt;int&gt; &amp;se, char a) const
	{
		vector&lt;int&gt; vis(v.size(), 0), ans;
		for (int j = 0; j &lt; se.size(); ++j)
			for (int u = se[j], i = 0, k; i &lt; v[u].o.size(); ++i)
				if (k = v[u].o[i], e[k].ch == a &amp;&amp; !vis[e[k].second])
					vis[e[k].second] = 1;
		for (int i = 0; i &lt; vis.size(); ++i)
			if (vis[i])
				ans.push_back(i);
		return ans;
	}
};
string regex_to_infix(string s)
{
	for (int i = 0; i + 1 &lt; s.size(); ++i)
		if (isalpha(s[i]) || s[i] == '?' || s[i] == '+' || s[i] == '*' || s[i] == ')')
			if (isalpha(s[i + 1]) || s[i + 1] == '(')
				s.insert(i + 1, "&amp;");
	return s;
}
string infix_to_suffix(const string &amp;s)
{
	string str, stak;
	static const unordered_map&lt;char, int&gt; priority{
		{'?', 3},
		{'+', 3},
		{'*', 3},
		{'&amp;', 2},
		{'|', 1},
		{'(', 0}};
	for (int i = 0; i &lt; s.size(); ++i)
	{
		if (isalpha(s[i]))
			str.push_back(s[i]);
		else if (s[i] == ')')
		{
			while (stak.back() != '(')
			{
				str.push_back(stak.back());
				stak.pop_back();
			}
			stak.pop_back();
		}
		else if (s[i] == '(')
			stak.push_back(s[i]);
		else
		{
			while (!stak.empty() &amp;&amp; priority.at(stak.back()) &gt;= priority.at(s[i]))
			{
				str.push_back(stak.back());
				stak.pop_back();
			}
			stak.push_back(s[i]);
		}
	}
	str.insert(str.end(), stak.rbegin(), stak.rend());
	return str;
}
Graph suffix_to_nfa(const string &amp;s)
{
	vector&lt;pair&lt;int, int&gt;&gt; stak;
	Graph nfa(2);
	for (int i = 0; i &lt; s.size(); ++i)
	{
		if (s[i] == '?')
		{
			int fi = nfa.v.size(),
				se = nfa.v.size() + 1,
				fi1 = stak.back().first,
				se1 = stak.back().second;
			stak.back() = {fi, se};
			nfa.add({fi, se, 'E'});
			nfa.add({fi, fi1, 'E'});
			nfa.add({se1, se, 'E'});
		}
		else if (s[i] == '+')
		{
			int fi1 = stak.back().first,
				se1 = stak.back().second;
			nfa.add({se1, fi1, 'E'});
		}
		else if (s[i] == '*')
		{
			int fi = nfa.v.size(),
				se = nfa.v.size() + 1,
				fi1 = stak.back().first,
				se1 = stak.back().second;
			stak.back() = {fi, se};
			nfa.add({fi, se, 'E'});
			nfa.add({fi, fi1, 'E'});
			nfa.add({se1, fi, 'E'});
		}
		else if (s[i] == '&amp;')
		{
			int fi2 = stak.back().first,
				se2 = stak.back().second;
			stak.pop_back();
			int fi1 = stak.back().first,
				se1 = stak.back().second;
			stak.back().second = se2;
			nfa.add({se1, fi2, 'E'});
		}
		else if (s[i] == '|')
		{
			int fi2 = stak.back().first,
				se2 = stak.back().second;
			stak.pop_back();
			int fi = nfa.v.size(),
				se = nfa.v.size() + 1,
				fi1 = stak.back().first,
				se1 = stak.back().second;
			stak.back() = {fi, se};
			nfa.add({fi, fi1, 'E'});
			nfa.add({fi, fi2, 'E'});
			nfa.add({se1, se, 'E'});
			nfa.add({se2, se, 'E'});
		}
		else
		{
			int fi = nfa.v.size(), se = nfa.v.size() + 1;
			nfa.add({fi, se, s[i]});
			stak.push_back({fi, se});
		}
	}
	nfa.add({0, stak.back().first, 'E'});
	nfa.add({stak.back().second, 1, 'E'});
	nfa.v[1].isAccepted = 1;
	return nfa;
}
Graph nfa_to_dfa(const Graph &amp;nfa)
{
	struct ID : map&lt;vector&lt;int&gt;, int&gt;
	{
		int ask(const vector&lt;int&gt; &amp;v)
		{
			if (count(v))
				return at(v);
			int s = size();
			return insert({v, s}), s;
		}
	} d_state;
	Graph dfa;
	for (vector&lt;vector&lt;int&gt;&gt; stak(1, nfa.closure({0})); !stak.empty();)
	{
		vector&lt;int&gt; se = stak.back();
		stak.pop_back();
		int id = d_state.ask(se);
		for (char a = 'a'; a &lt;= 'z'; ++a)
		{
			vector&lt;int&gt; se2 = nfa.closure(nfa.a_move(se, a));
			if (!d_state.count(se2))
				stak.push_back(se2);
			dfa.add({id, d_state.ask(se2), a});
		}
	}
	for (ID::iterator it = d_state.begin(); it != d_state.end(); ++it)
		if (find(it-&gt;first.begin(), it-&gt;first.end(), 1) != it-&gt;first.end())
			dfa.v[it-&gt;second].isAccepted = 1;
	return dfa;
}
int contain(const Graph &amp;lhs, const Graph &amp;rhs)
{
	vector&lt;vector&lt;int&gt;&gt; vis(lhs.v.size(), vector&lt;int&gt;(rhs.v.size(), 0));
	for (vector&lt;pair&lt;int, int&gt;&gt; q(vis[0][0] = 1, {0, 0}); !q.empty();)
	{
		int xl = q.back().first,
			xr = q.back().second;
		q.pop_back();
		if (lhs.v[xl].isAccepted &lt; rhs.v[xr].isAccepted)
			return 0;
		for (int i = 0; i &lt; lhs.v[xl].o.size(); ++i)
		{
			int yl = lhs.e[lhs.v[xl].o[i]].second,
				yr = rhs.e[rhs.v[xr].o[i]].second;
			if (!vis[yl][yr])
				vis[yl][yr] = 1, q.push_back({yl, yr});
		}
	}
	return 1;
}
int main()
{
	int t;
	for (cin &gt;&gt; t; t--;)
	{
		string a, b;
		cin &gt;&gt; a &gt;&gt; b;
		const Graph
			dfa = nfa_to_dfa(suffix_to_nfa(infix_to_suffix(regex_to_infix(a)))),
			dfb = nfa_to_dfa(suffix_to_nfa(infix_to_suffix(regex_to_infix(b))));
		cout &lt;&lt; "!&lt;&gt;="[contain(dfa, dfb) &lt;&lt; 1 | contain(dfb, dfa)] &lt;&lt; "\n";
	}
}
</code></pre></div><script repo="wu-kan/utterances-storage" src="https://utteranc.es/client.js" issue-term="url" theme="github-light" crossorigin="anonymous" async="async" ></script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" /><style> .katex-display>.katex { white-space: normal; }</style><script src="https://cdn.jsdelivr.net/combine/npm/katex@0.13.11/dist/katex.min.js,npm/katex@0.13.11/dist/contrib/auto-render.min.js" async="async" onload='renderMathInElement(document.body, { delimiters: [{left: "$$", right: "$$", display: true}, { left: "$", right: "$", display: false }, {left: "\\(", right: "\\)", display: false}, {left: "\\[", right: "\\]", display: true}]})' ></script><style> pre.language-mermaid, code.language-mermaid { display: none; } @media only screen { .mermaid { overflow: auto auto; max-width: 100%; max-height: 66.6vh; } }</style><script src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" async="async" onload=' for(let x of document.getElementsByClassName("language-mermaid")) if(x.nodeName=="CODE") { let m = document.createElement("div"); m.classList.add("mermaid"); m.textContent = x.textContent; x.parentNode.insertAdjacentElement("beforebegin", m); }' ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.css,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.css,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.css,npm/prism-themes@1.5.0/themes/prism-nord.min.css" /> <script src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/components/prism-core.min.js,npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js,npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.js,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.js" async="async" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/" onload=' for(let x of document.getElementsByClassName("content")) x.classList.add("line-numbers","match-braces"); Prism.plugins.toolbar.registerButton("select-code", function (env) { let button = document.createElement("button"); button.textContent = "select this " + env.language; button.addEventListener("click", function () { if (document.body.createTextRange) { let range = document.body.createTextRange(); range.moveToElementText(env.element); range.select(); } else if (window.getSelection) { let selection = window.getSelection(); let range = document.createRange(); range.selectNodeContents(env.element); selection.removeAllRanges(); selection.addRange(range); } }); return button; })' ></script></div><label for="sidebar-checkbox" class="sidebar-toggle"></label>
