<!DOCTYPE html><html><head><title> 链表求序 &middot; wu-kan</title><!-- Begin Jekyll SEO tag v2.7.1 --><meta name="generator" content="Jekyll v3.9.0" /><meta property="og:title" content="链表求序" /><meta property="og:locale" content="en_US" /><meta name="description" content="用 MPI 和 CUDA 实现链表求序（linked list ranking）算法，并与串行程序比较。" /><meta property="og:description" content="用 MPI 和 CUDA 实现链表求序（linked list ranking）算法，并与串行程序比较。" /><link rel="canonical" href="http://localhost:4000/2020/01/13/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%BA%8F/" /><meta property="og:url" content="http://localhost:4000/2020/01/13/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%BA%8F/" /><meta property="og:site_name" content="wu-kan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-01-13T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="链表求序" /><meta name="google-site-verification" content="YIKi1rBnyUaS-DMYiluseI5kZzTwjCkTFmKkSkMZDJk" /><meta name="baidu-site-verification" content="szbTSfUGAB" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"http://localhost:4000/2020/01/13/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%BA%8F/","datePublished":"2020-01-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/01/13/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%BA%8F/"},"headline":"链表求序","description":"用 MPI 和 CUDA 实现链表求序（linked list ranking）算法，并与串行程序比较。","dateModified":"2020-01-13T00:00:00+08:00","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" /><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="alternate" href="/feed.xml" title="RSS" type="application/rss+xml" /><link rel="apple-touch-icon-precomposed" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" /><link rel="shortcut icon" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=32" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/poole/lanyon@v1.1.0/public/css/poole.min.css,gh/poole/lanyon@v1.1.0/public/css/lanyon.min.css,gh/poole/lanyon@v1.1.0/public/css/syntax.min.css" /> <script async="async" src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/js/all.min.js" ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dreamer-Paul/Pio@2.4/static/pio.min.css" /><style> @media only print { .pio-container { display: none; } }</style><script async="async" src="https://cdn.jsdelivr.net/combine/gh/Dreamer-Paul/Pio@2.4/static/l2d.min.js,gh/Dreamer-Paul/Pio@2.4/static/pio.min.js" onload=' let pio_container = document.createElement("div"); pio_container.classList.add("pio-container"); pio_container.classList.add("right"); pio_container.style.bottom = "-2rem"; pio_container.style.zIndex = "1"; document.body.insertAdjacentElement("beforeend", pio_container); let pio_action = document.createElement("div"); pio_action.classList.add("pio-action"); pio_container.insertAdjacentElement("beforeend", pio_action); let pio_canvas = document.createElement("canvas"); pio_canvas.id = "pio"; pio_canvas.style.width = "14rem"; pio_canvas.width = "600"; pio_canvas.height = "800"; pio_container.insertAdjacentElement("beforeend", pio_canvas); let pio = new Paul_Pio({ "mode": "fixed", "hidden": true, "night": "for(let i=7; i<16; ++i) if(document.body.classList.contains(`theme-base-0`+i.toString(16))) { document.body.classList.remove(`theme-base-0`+i.toString(16)); document.body.classList.add(`theme-base-0`+((i-6)%9+7).toString(16)); break; }", "content": { "link": ["https:\/\/jekyll-theme-WuK.wu-kan.cn"], "skin": ["要换成我的朋友吗？", "让她放个假吧~"], "hidden": true, "custom": [{ "selector": "a", "type": "link", }, { "selector": ".sidebar-toggle", "text": "打开侧边栏叭~" }, { "selector": ".effect-info", "text": "哇，你发现了什么！" }, { "selector": "#sidebar-search-input", "text": "想搜索什么呢？很多干货哦！" }, { "selector": "#toc", "text": "这是目录~" }, { "selector": ".page-title", "text": "这是标题~" }, { "selector": ".v", "text": "评论没有审核，要对自己的发言负责哦~" }] }, "model": [ "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/33/model.2018.bls-winter.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/platelet-2/model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/xiaomai/xiaomai.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/mashiro/seifuku.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/Violet/14.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/Kobayaxi/Kobayaxi.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/mikoto/mikoto.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/uiharu/uiharu.model.json"] });' ></script> <script src='https://zz.bdstatic.com/linksubmit/push.js' async="async" ></script><style> .wrap { transition-property: width,background-size,transform; transition-duration: .3s; transition-timing-function: ease-in-out; min-height: 100%; display: inline-block; background-size: 100% auto; background-position: 0% 0%; background-repeat: no-repeat; background-attachment: fixed; background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/74559485_p1.webp); } @media (min-aspect-ratio: 2400/1850) { .wrap { background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/71932901_p0.webp); } } .sidebar-overlay #sidebar-checkbox:checked ~ .wrap { width: calc(100% - 14rem); background-size: calc(100% - 14rem) auto; transform: translateX(14rem); } .layout-reverse.sidebar-overlay #sidebar-checkbox:checked ~ .wrap { transform: translateX(0); }</style><style> .sidebar, html, h1, h2, h3, h4, h5, h6 { font-family: "Courier New", "Courier", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Microsoft YaHei Light", "Microsoft JhengHei", monospace; }</style><style> td, th { padding: 0px; border: 0px; } table { border: 0px; } table tbody { display: block; overflow: scroll; } table thead, tbody tr { display: table; table-layout: fixed; width: 100%; }</style><style> img { display: inline-block; margin: 0; }</style><style> ::-webkit-scrollbar { width: 3px; height: 3px; } ::-webkit-scrollbar-thumb { background-image: linear-gradient(45deg, Cyan 0%, Magenta 50%, Yellow 100%); }</style><style> ::selection { color: White; background: Black; }</style><body class="theme-base-0d layout-reverse sidebar-overlay"> <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. --> <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" /> <!-- Toggleable sidebar --><div class="sidebar" id="sidebar"><div class="sidebar-item"><div class="effect effect-right_to_left"> <img class="effect-img" src="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" alt="img" /><div class="effect-info"> SYSU超算17级在读<br/> 水野爱<br/> HPC<br/> 田宫例四驱车<br/> <a href="mailto:i@wu-kan.cn"> <i class="fas fa-envelope"></i> </a> <a href="https://github.com/wu-kan"> <i class="fab fa-github"></i> </a> <a href="https://codeforces.com/profile/WuK"> <i class="fas fa-chart-bar"></i> </a> <a href="https://vjudge.net/user/WuK"> <i class="fas fa-smile"></i> </a> <a href="https://www.zhihu.com/people/wu.kan/activities"> <i class="fab fa-zhihu"></i> </a> <iframe src="https://music.163.com/outchain/player?type=0&id=155059595&auto=0&height=32" width=100% height=52 frameborder="no" border="0" marginwidth="0" marginheight="0" ></iframe></div></div></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/"> <i class="fas fa-home fa-fw"></i> 首页 </a> <a class="sidebar-nav-item" href="/comments/"> <i class="fas fa-comments fa-fw"></i> 留言 </a> <a class="sidebar-nav-item" href="/tags/"> <i class="fas fa-tags fa-fw"></i> 标签 </a> <a class="sidebar-nav-item" href="/archive/"> <i class="fas fa-archive fa-fw"></i> 归档 </a> <a class="sidebar-nav-item" href="/merger/"> <i class="fas fa-coffee fa-fw"></i> 打赏 </a></nav><div class="sidebar-item"><style> #sidebar-search-input { background: none; border: none; color: White; width: 100%; } #sidebar-search-results-container { overflow: auto auto; max-height: 66.6vh; }</style><input id="sidebar-search-input" placeholder="搜索博文" /><ol id="sidebar-search-results-container" ></ol><script src='https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.9.1' async='async' onload=' SimpleJekyllSearch({ json: "/assets/simple-jekyll-search/search.json", searchInput: document.getElementById("sidebar-search-input"), resultsContainer: document.getElementById("sidebar-search-results-container"), searchResultTemplate: `<li><a href="{url}">{title}</a>`, limit: 999, fuzzy: true })' ></script><style> #toc { overflow: auto auto; max-height: 66.6vh; }</style><ol id="toc"><li><a href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83">实验环境</a><li><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%88%86%E6%9E%90">实验过程与分析</a><ol><li><a href="#%E8%B0%83%E5%BA%A6%E8%84%9A%E6%9C%AClist_rankingpbs">调度脚本list_ranking.pbs</a><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4list_rankingo17502">运行时间list_ranking.o17502</a><li><a href="#%E6%9E%84%E9%80%A0%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AEgen_list_ranking_datac">构造生成数据gen_list_ranking_data.c</a><li><a href="#%E4%B8%B2%E8%A1%8C%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95">串行扫描算法</a><li><a href="#mpi-%E5%AE%9E%E7%8E%B0%E7%9A%84-wyllie-%E7%AE%97%E6%B3%95list_ranking_mpic">MPI 实现的 Wyllie 算法list_ranking_mpi.c</a><li><a href="#cuda-%E5%AE%9E%E7%8E%B0%E7%9A%84-wyllie-%E7%AE%97%E6%B3%95list_ranking_cudacu">CUDA 实现的 Wyllie 算法list_ranking_cuda.cu</a></ol><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></ol><style> .sidebar-checkbox { display: none; } .sidebar-toggle { position: fixed; }</style><style> .sidebar { overflow: scroll; min-height: 101%; }</style><style> .effect { margin: 1rem; perspective: 900px; } .effect-info { text-align: center; position: absolute; top: 0; transform-style: preserve-3d; } .effect-img { z-index: 11; width: 100%; height: 100%; position: relative; transition: all 0.5s ease-in-out; } .effect-img:before { position: absolute; display: block; } .effect-right_to_left .effect-img { transform-origin: 0% 50%; } .effect-right_to_left:hover .effect-img { transform: rotate3d(0, 1, 0, -180deg); }</style><div> <i class="fas fa-cog fa-spin fa-fw"></i> <span id="run_time_day"> <i class="fas fa-spinner fa-pulse"></i> </span>天 <span id="run_time_hour"> <i class="fas fa-spinner fa-pulse"></i> </span>时 <span id="run_time_minute"> <i class="fas fa-spinner fa-pulse"></i> </span>分 <span id="run_time_second"> <i class="fas fa-spinner fa-pulse"></i> </span>秒 <script> setInterval(function (d,h,m,s,b) { function setzero(i) { return i < 10 ? "0" + i : i; } let BirthDay = new Date(b); let today = new Date(); let timeold = (today.getTime() - BirthDay.getTime()); let sectimeold = timeold / 1000; let secondsold = Math.floor(sectimeold); let msPerDay = 24 * 60 * 60 * 1000; let e_daysold = timeold / msPerDay; let daysold = Math.floor(e_daysold); let e_hrsold = (e_daysold - daysold) * 24; let hrsold = Math.floor(e_hrsold); let e_minsold = (e_hrsold - hrsold) * 60; let minsold = Math.floor((e_hrsold - hrsold) * 60); let seconds = Math.floor((e_minsold - minsold) * 60); d.textContent = daysold; h.textContent = setzero(hrsold); m.textContent = setzero(minsold); s.textContent = setzero(seconds); }, 1000, document.getElementById("run_time_day"), document.getElementById("run_time_hour"), document.getElementById("run_time_minute"), document.getElementById("run_time_second"), "10/04/2017 11:03:56")// 这是我第一篇CSDN博客的时间 </script></div><div><div> <i class="fas fa-eye fa-fw"></i> <span id="busuanzi_value_page_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>次</div><div> <i class="fas fa-paw fa-fw"></i> <span id="busuanzi_value_site_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>枚</div><div> <i class="fas fa-user-friends fa-fw"></i> <span id="busuanzi_value_site_uv"> <i class="fas fa-spinner fa-pulse"></i> </span>人</div><script src='https://cdn.jsdelivr.net/npm/busuanzi@2.3.0' async='async' ></script></div><div> <i class="fas fa-thumbs-up fa-fw"></i> <a href="https://jekyll-theme-WuK.wu-kan.cn"> jekyll-theme-WuK </a></div><div> <i class="fas fa-copyright fa-fw"></i> 2017-2021 WuK</div><div> <i class="fas fa-info-circle fa-fw"></i> <a href="http://beian.miit.gov.cn"> 粤ICP备 20024947号 </a></div><div> <img src="https://i.loli.net/2021/03/17/Y47tDZTrcy2xwRa.png" class="fa-fw"></img> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=34070202000407"> 皖公网安备 34070202000407号 </a></div></div></div><!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --><div class="wrap"><style> @media only screen { pre { max-height: 66.6vh; overflow: auto; } }</style><style> .container { min-width: 66.6%; } @media only print { .container { min-width: 100%; } }</style><style> .container.content { padding: 2rem; box-shadow: 0 0 2rem rgba(255,255,255,0.9); background-color: rgba(255,255,255,0.9); animation-duration: 2s; animation-name: fadeIn; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }</style><div class="container content"><div class="page"><h1 class="page-title">链表求序</h1><div class="post"> <span class="post-date"> <i class="fas fa-calendar-day fa-fw"></i> 13 Jan 2020 <i class="fas fa-file-word fa-fw"></i> 9402字 <i class="fas fa-clock fa-fw"></i> 32分 <br/> <i class="fas fa-coffee fa-fw"></i> <a href="/merger/">如果这篇博客帮助到你，可以请我喝一杯咖啡~</a> <br/> <i class="fab fa-creative-commons-by fa-fw"></i> <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="license"> CC BY 4.0 </a> （除特别声明或转载文章外） </span><p>用 MPI 和 CUDA 实现链表求序（linked list ranking）算法，并与串行程序比较。</p><ul><li>输入：一个 N 元素的单向链表，该链表放在一个长度为 N 的向量中。链表的每一个元素（除链尾的一个）都有一个后继的数组下标。链尾的元素的后继为<code>-1</code>。<li>输出：定义链表元素的序号（rank）为「其后继的总数」，例如链头的序号为 N-1、链尾的序号为 0。向量中的元素不一定按照链表的顺序存放。要求算出每一个向量元素的序号。</ul><h2 id="实验环境">实验环境</h2><p>实验在老师提供的计算集群的一个节点上进行。单节点的显卡配置如下：</p><pre><code class="language-bash">$ nvdia-smi
Mon Dec  2 08:38:49 2019
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 410.48                 Driver Version: 410.48                    |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  Tesla V100-PCIE...  On   | 00000000:3B:00.0 Off |                    0 |
| N/A   30C    P0    24W / 250W |      0MiB / 16130MiB |      0%      Default |
+-------------------------------+----------------------+----------------------+

+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID   Type   Process name                             Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+
</code></pre><h2 id="实验过程与分析">实验过程与分析</h2><p>List Ranking 是一个比较经典的研究并行算法设计的问题，因为这个问题的并行算法相对于串行版本很难有十分明显的速度改进。但是并行化的好处并不仅仅是提速。</p><p>比如，单机上的内存总量很多情况下是不足够的，而多机并行的时候可以使用更大的内存。针对这一问题，并行化的优点是可以通过扩充硬件的规模从而扩充能够处理问题的规模，这是串行程序比不了的。</p><h3 id="调度脚本list_rankingpbs">调度脚本<code>list_ranking.pbs</code></h3><p>这里由于临近期末，集群资源比较紧张，所有的调度都只占用集群上的一个节点进行。MPI 使用一台主机上的 32 个核进行并行；CUDA 使用节点上的单张 v100 显卡。为方便起见，我将所有的测试代码写进了一个测试脚本<code>list_ranking.pbs</code>中，这样直接对这个脚本进行调度运行即可自动运行完整实验并进行计时。</p><pre><code class="language-bash">#PBS -N list_ranking
#PBS -l nodes=1:ppn=32:gpus=1
#PBS -j oe
#PBS -q gpu
source /public/software/profile.d/mpi_openmpi-intel-2.1.2.sh
source /public/software/profile.d/cuda10.0.sh
cd $PBS_O_WORKDIR

gcc gen_list_ranking_data.c -o gen_list_ranking_data -std=c99
./gen_list_ranking_data &gt; list_ranking_data.txt

gcc list_ranking.c -o list_ranking -std=c99
time ./list_ranking &lt; list_ranking_data.txt &gt; list_ranking_out.txt

mpicc list_ranking_mpi.c -o list_ranking_mpi -std=c99
time mpiexec -machinefile $PBS_NODEFILE ./list_ranking_mpi &lt; list_ranking_data.txt &gt; list_ranking_mpi_out.txt

nvcc list_ranking_cuda.cu -o list_ranking_cuda
time ./list_ranking_cuda &lt; list_ranking_data.txt &gt; list_ranking_cuda_out.txt
</code></pre><h3 id="运行时间list_rankingo17502">运行时间<code>list_ranking.o17502</code></h3><p>自上而下分别是串行算法的时间（<code>1.977s</code>），MPI 算法的时间（<code>5.976s</code>），CUDA 算法的时间（<code>3.246s</code>）。可以看到，这里实现的两个并行算法都在不过分增加并行开销的情况下增加了串行算法的可扩展性。</p><p><strong>这个问题中并行算法是不可能快于同等情况下的串行算法的</strong>，因为串行算法的时间复杂度是$O(n)$，而读入这个向量的时间复杂度已经是$O(n)$了，并行算法无论如何都需要先读入向量，时间复杂度上不可能优于$O(n)$。</p><pre><code class="language-bash">
real	0m1.977s
user	0m1.710s
sys	0m0.176s

real	0m5.976s
user	1m20.123s
sys	0m32.837s

real	0m3.246s
user	0m2.251s
sys	0m0.806s
</code></pre><h3 id="构造生成数据gen_list_ranking_datac">构造生成数据<code>gen_list_ranking_data.c</code></h3><p>此处我使用了老师提供的数据生成器。</p><pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int *gen_linked_list_1(unsigned int N)
{

    int *list = NULL;
    if (NULL != list)
    {
        free(list);
        list = NULL;
    }

    if (0 == N)
    {
        printf("N is 0, exit\n");
        exit(-1);
    }

    list = (int *)malloc(N * sizeof(int));
    if (NULL == list)
    {
        printf("Can not allocate memory for output array\n");
        exit(-1);
    }

    int i;
    for (i = 0; i &lt; N; i++)
        list[i] = i - 1;

    return list;
}

//i和j的后继元素交换位置
void swap(int *list, int i, int j)
{
    if (i &lt; 0 || j &lt; 0 || i == j)
        return;

    int p = list[i]; //保存i后继元素下标p
    int q = list[j]; //保存j后继元素下标q

    if (p == -1 || q == -1)
        return; //如果有一个没有后继元素

    int pnext = list[p]; //保存p的后继元素下标
    int qnext = list[q]; //保存q的后继元素下标

    //i,j的后继元素交换位置
    if (p == j)
    { //j是i的后继
        list[i] = q;
        list[j] = list[q];
        list[q] = j;
    }
    else if (i == q)
    { //i是j的后继
        list[j] = p;
        list[i] = list[p];
        list[p] = i;
    }
    else
    {
        list[i] = q;     //i的后继改为q
        list[j] = p;     //j的后继改为p
        list[p] = qnext; //p的后继元素改为原来q的后继
        list[q] = pnext; //q的后继元素改为原来p的后继
    }
}

int *gen_linked_list_2(unsigned int N)
{
    int *list;

    list = gen_linked_list_1(N);

    int p = N / 5;

    int i, temp, k;

    for (i = 0; i &lt; N; i += 2)
    {
        int k = (i + i + p) % N;
        swap(list, i, k);
    }

    return list;
}

int main()
{

    int N = 10000000;
    int *qq = NULL;
    int i;
    // qq=gen_linked_list_1(N);
    // printf("\nhere is the list\n");
    // for(i=0; i&lt;N; i++)
    // printf("%3d ", qq[i]);
    // printf("\n");
    // free(qq);
    qq = gen_linked_list_2(N);
    //printf("\nhere is the new list\n");
    printf("%3d ", N); //输出链表元素个数
    printf("\n");
    for (i = 0; i &lt; N; i++) //输出链表全部元素
        printf("%3d ", qq[i]);
    printf("\n");

    free(qq);

    return 0;
}
</code></pre><p>终端执行下述指令，得到用于测试的数据<code>list_ranking_data.txt</code>。</p><pre><code class="language-bash">gcc gen_list_ranking_data.c -o gen_list_ranking_data -std=c99
./gen_list_ranking_data &gt; list_ranking_data.txt
</code></pre><p><code>list_ranking_data.txt</code>有着如下的结构，这里只放出向量的前四个元素。</p><pre><code class="language-bash">10000000
-1 4000014 2000003 4000030 ...
</code></pre><h3 id="串行扫描算法">串行扫描算法</h3><p>最简单的串行算法即扫描整个列表。解释一下整个算法的过程：</p><ol><li>读入向量<code>v</code><li>根据<code>v</code>计算每个元素的前驱<code>pre</code>，同时找出链表尾<code>last</code><li>从链表尾<code>last</code>开始顺次访问前驱<code>pre</code>，遍历的顺序就是我们要求的链表序。</ol><pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
	int n, last;
	scanf("%d", &amp;n);
	int *v = (int *)malloc(sizeof(int) * n),
		*a = (int *)malloc(sizeof(int) * n),
		*pre = (int *)malloc(sizeof(int) * n);
	for (int i = 0; i &lt; n; ++i)
		scanf("%d", &amp;v[i]);
	for (int i = 0; i &lt; n; ++i)
	{
		if (v[i] &lt; 0)
			last = i;
		else
			pre[v[i]] = i;
	}
	for (int u = last, i = n - 1; i &gt;= 0; --i, u = pre[u])
		a[u] = i;
	for (int i = 0; i &lt; n; ++i)
		printf("%d ", a[i]);
	free(pre);
	free(a);
	free(v);
}
</code></pre><p>终端执行下属指令，可以计时执行并将结果写入<code>list_ranking_out.txt</code>。</p><pre><code class="language-bash">gcc list_ranking.c -o list_ranking -std=c99
time ./list_ranking &lt; list_ranking_data.txt &gt; list_ranking_out.txt
</code></pre><p><code>list_ranking_out.txt</code>前四个元素为如下的结构，手动检查第一个元素的 ranking 是<code>9999999</code>，是正确的。</p><pre><code class="language-bash">9999999 5999984 9999997 5999968 ...
</code></pre><p><strong>直接串行扫描算法修改出来的并行算法不会有理想的加速效果。</strong>理由是，下面这段代码中，重复执行<code>u = pre[u]</code>从链表尾开始依次向前找前驱节点，这个过程是串行的，有循环依赖，不可以直接划分到多进程并行执行。</p><pre><code class="language-c">for (int u = last, i = n - 1; i &gt;= 0; --i, u = pre[u])
	a[u] = i;
</code></pre><h3 id="mpi-实现的-wyllie-算法list_ranking_mpic">MPI 实现的 Wyllie 算法<code>list_ranking_mpi.c</code></h3><p>即使用 point jumping（点倍增）的方法来计算各个 rank，是最简单的并行算法。</p><blockquote><p>Wyllie 算法原理：</p><pre><code class="language-python">for i in range(n): # 初始化，其中v代表初始向量，即每个节点后继
    a[i] = v[i]&gt;=0 # a代表每个节点
while exists(i =&gt; v[i]&gt;=0): # 此部分并行执行，每轮迭代要同步
    a[i] += a[v[i]]
    v[i] = v[v[i]]
</code></pre></blockquote><p>如上面的伪代码，初始化过程和每轮迭代都是可以划分到多进程执行的。当然，这里得到的<code>a</code>是到链表尾部的距离，用链表长度相减就能得到我们所需要的序号。</p><pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mpi.h&gt;
int main(int argc, char **argv)
{
	int comSize, comRank, n;
	MPI_Init(&amp;argc, &amp;argv);
	MPI_Comm_size(MPI_COMM_WORLD, &amp;comSize);
	MPI_Comm_rank(MPI_COMM_WORLD, &amp;comRank);

	if (!comRank)
		scanf("%d", &amp;n);

	MPI_Bcast(
		&amp;n,
		1,
		MPI_INT,
		0,
		MPI_COMM_WORLD);

	int myLen = (n + comSize - 1) / comSize,
		myBeg = comRank * myLen,
		*myV = (int *)malloc(sizeof(int) * myLen),
		*myA = (int *)malloc(sizeof(int) * myLen),
		*v = (int *)malloc(sizeof(int) * n),
		*a = (int *)malloc(sizeof(int) * n);

	if (!comRank)
		for (int i = 0; i &lt; n; ++i)
			scanf("%d", &amp;v[i]);

	MPI_Bcast(
		v,
		n,
		MPI_INT,
		0,
		MPI_COMM_WORLD);

	for (int i = 0; i &lt; myLen; ++i)
	{
		myV[i] = v[i + myBeg];
		myA[i] = myV[i] &gt;= 0;
	}

	MPI_Allgather(
		myA,
		myLen,
		MPI_INT,
		a,
		myLen,
		MPI_INT,
		MPI_COMM_WORLD);

	for (int j = 1; j &lt; n; j &lt;&lt;= 1)
	{
		for (int i = 0; i &lt; myLen; ++i)
			if (v[i + myBeg] &gt;= 0)
			{
				myA[i] = a[i + myBeg] + a[v[i + myBeg]];
				myV[i] = v[v[i + myBeg]];
			}

		MPI_Allgather(
			myA,
			myLen,
			MPI_INT,
			a,
			myLen,
			MPI_INT,
			MPI_COMM_WORLD);

		MPI_Allgather(
			myV,
			myLen,
			MPI_INT,
			v,
			myLen,
			MPI_INT,
			MPI_COMM_WORLD);
	}

	if (!comRank)
		for (int i = 0; i &lt; n; ++i)
			printf("%d ", n - 1 - a[i]);

	free(myV);
	free(myA);
	free(v);
	free(a);
	MPI_Finalize();
}
</code></pre><p>终端执行下述指令，可以计时执行并将结果写入<code>list_ranking_mpi_out.txt</code>。</p><pre><code class="language-bash">mpicc list_ranking_mpi.c -o list_ranking_mpi -std=c99
time mpiexec -machinefile $PBS_NODEFILE ./list_ranking_mpi &lt; list_ranking_data.txt &gt; list_ranking_mpi_out.txt
</code></pre><p><code>list_ranking_mpi_out.txt</code>前四个元素为如下的结构，手动检查第一个元素的 ranking 是<code>9999999</code>，是正确的；<code>list_ranking_mpi_out.txt</code>与<code>list_ranking_out.txt</code>完全相同。</p><pre><code class="language-bash">9999999 5999984 9999997 5999968 ...
</code></pre><h3 id="cuda-实现的-wyllie-算法list_ranking_cudacu">CUDA 实现的 Wyllie 算法<code>list_ranking_cuda.cu</code></h3><p>另一种并行链表求序的 SMP 算法[Helman and JaJa, 1999]需要提前知道链表中等分点的分布，不是很适合本例，因此用 CUDA 实现的仍然是 Wyllie 算法。</p><p>相比于 MPI 实现的版本，这里没有了节点广播 Bcast 和全聚集 Allgather 的开销，因此时间上快了非常多。然而，仍然需要考虑的是，核函数 work 对<code>v[v[idx]]</code>和<code>a[v[idx]]</code>的访问没有对齐，这是算法的瓶颈所在。</p><pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void __global__ init(int n, int *v, int *a)
{
	int idx = blockIdx.x * blockDim.x + threadIdx.x;
	a[idx] = v[idx] &gt;= 0;
}
void __global__ work(int n, int *v, int *a, int *new_v, int *new_a)
{
	int idx = blockIdx.x * blockDim.x + threadIdx.x;
	if (v[idx] &gt;= 0)
	{
		new_a[idx] = a[idx] + a[v[idx]];
		new_v[idx] = v[v[idx]];
	}
}
int main()
{
	int n;
	scanf("%d", &amp;n);

	int *v = (int *)malloc(sizeof(int) * n),
		*d_v,
		*d_v1,
		*d_a,
		*d_a1,
		block = 32, grid = n / block;

	for (int i = 0; i &lt; n; ++i)
		scanf("%d", &amp;v[i]);

	cudaMalloc(&amp;d_a, sizeof(int) * n);
	cudaMalloc(&amp;d_a1, sizeof(int) * n);
	cudaMalloc(&amp;d_v, sizeof(int) * n);
	cudaMalloc(&amp;d_v1, sizeof(int) * n);
	cudaMemcpy(d_v, v, sizeof(int) * n, cudaMemcpyHostToDevice);

	init&lt;&lt;&lt;grid, block&gt;&gt;&gt;(n, d_v, d_a);
	cudaDeviceSynchronize();

	for (int j = 1; j &lt; n; j &lt;&lt;= 1)
	{
		work&lt;&lt;&lt;grid, block&gt;&gt;&gt;(n, d_v, d_a, d_v1, d_a1);
		cudaDeviceSynchronize();
		int *tmp;
		tmp = d_v, d_v = d_v1, d_v1 = tmp;
		tmp = d_a, d_a = d_a1, d_a1 = tmp;
	}

	cudaMemcpy(v, d_a, sizeof(int) * n, cudaMemcpyDeviceToHost);

	for (int i = 0; i &lt; n; ++i)
		printf("%d ", n - 1 - v[i]);

	cudaFree(d_v);
	cudaFree(d_a);
	cudaFree(d_v1);
	cudaFree(d_a1);
	free(v);
}
</code></pre><p>终端执行下述指令，可以计时执行并将结果写入<code>list_ranking_cuda_out.txt</code>。</p><pre><code class="language-cpp">nvcc list_ranking_cuda.cu -o list_ranking_cuda
time ./list_ranking_cuda &lt; list_ranking_data.txt &gt; list_ranking_cuda_out.txt
</code></pre><p><code>list_ranking_cuda_out.txt</code>前四个元素为如下的结构，手动检查第一个元素的 ranking 是<code>9999999</code>，是正确的；<code>list_ranking_cuda_out.txt</code>与<code>list_ranking_out.txt</code>完全相同。</p><pre><code class="language-bash">9999999 5999984 9999997 5999968 ...
</code></pre><h2 id="参考文献">参考文献</h2><ul><li><a href="http://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/chap30.htm">http://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/chap30.htm</a><li><a href="https://en.wikipedia.org/wiki/Pointer_jumping">https://en.wikipedia.org/wiki/Pointer_jumping</a><li><a href="http://www.cs.cmu.edu/~scandal/alg/listrank.html">http://www.cs.cmu.edu/~scandal/alg/listrank.html</a><li><a href="https://www.cs.cmu.edu/~glmiller/Publications/Papers/ReMiMo93.pdf">https://www.cs.cmu.edu/~glmiller/Publications/Papers/ReMiMo93.pdf</a><li><a href="http://cdn.iiit.ac.in/cdn/cstar.iiit.ac.in/~kkishore/ics152-rehman.pdf">http://cdn.iiit.ac.in/cdn/cstar.iiit.ac.in/~kkishore/ics152-rehman.pdf</a><li>D. Bader, G. Cong, and J. Feo. On the Architectural Requirements for Efficient Execution of Graph Algorithms. International Conference on Parallel Processing (ICPP), 2005, pages 547-556, June 2005.<li>D. A. Bader, V. Agarwal, and K. Madduri. On the Design and Analysis of Irregular Algorithms on the Cell Processor: A Case Study of List Ranking. In 21st IEEE International Parallel and Distributed Processing Symposium (IPDPS), pages 1-10. IEEE, 2007.<li>D. A. Bader and G. Cong. A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors (SMPs). Journal of Parallel and Distributed Computing, 65(9):994 - 1006, 2005.<li><a href="https://link.springer.com/content/pdf/10.1007%2FBFb0056600.pdf">https://link.springer.com/content/pdf/10.1007%2FBFb0056600.pdf</a></ul></div><script repo="wu-kan/utterances-storage" src="https://utteranc.es/client.js" issue-term="url" theme="github-light" crossorigin="anonymous" async="async" ></script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" /><style> .katex-display>.katex { white-space: normal; }</style><script src="https://cdn.jsdelivr.net/combine/npm/katex@0.13.11/dist/katex.min.js,npm/katex@0.13.11/dist/contrib/auto-render.min.js" async="async" onload='renderMathInElement(document.body, { delimiters: [{left: "$$", right: "$$", display: true}, { left: "$", right: "$", display: false }, {left: "\\(", right: "\\)", display: false}, {left: "\\[", right: "\\]", display: true}]})' ></script><style> pre.language-mermaid, code.language-mermaid { display: none; } @media only screen { .mermaid { overflow: auto auto; max-width: 100%; max-height: 66.6vh; } }</style><script src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" async="async" onload=' for(let x of document.getElementsByClassName("language-mermaid")) if(x.nodeName=="CODE") { let m = document.createElement("div"); m.classList.add("mermaid"); m.textContent = x.textContent; x.parentNode.insertAdjacentElement("beforebegin", m); }' ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.css,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.css,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.css,npm/prism-themes@1.5.0/themes/prism-nord.min.css" /> <script src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/components/prism-core.min.js,npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js,npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.js,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.js" async="async" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/" onload=' for(let x of document.getElementsByClassName("content")) x.classList.add("line-numbers","match-braces"); Prism.plugins.toolbar.registerButton("select-code", function (env) { let button = document.createElement("button"); button.textContent = "select this " + env.language; button.addEventListener("click", function () { if (document.body.createTextRange) { let range = document.body.createTextRange(); range.moveToElementText(env.element); range.select(); } else if (window.getSelection) { let selection = window.getSelection(); let range = document.createRange(); range.selectNodeContents(env.element); selection.removeAllRanges(); selection.addRange(range); } }); return button; })' ></script></div><label for="sidebar-checkbox" class="sidebar-toggle"></label>
