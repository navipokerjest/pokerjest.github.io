<!DOCTYPE html><html><head><title> Educational Codeforces Round 98 (Rated for Div. 2) &middot; wu-kan</title><!-- Begin Jekyll SEO tag v2.7.1 --><meta name="generator" content="Jekyll v3.9.0" /><meta property="og:title" content="Educational Codeforces Round 98 (Rated for Div. 2)" /><meta property="og:locale" content="en_US" /><meta name="description" content="官方题解" /><meta property="og:description" content="官方题解" /><link rel="canonical" href="http://localhost:4000/2020/11/19/Educational-Codeforces-Round-98-(Rated-for-Div.-2)/" /><meta property="og:url" content="http://localhost:4000/2020/11/19/Educational-Codeforces-Round-98-(Rated-for-Div.-2)/" /><meta property="og:site_name" content="wu-kan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-11-19T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Educational Codeforces Round 98 (Rated for Div. 2)" /><meta name="google-site-verification" content="YIKi1rBnyUaS-DMYiluseI5kZzTwjCkTFmKkSkMZDJk" /><meta name="baidu-site-verification" content="szbTSfUGAB" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"http://localhost:4000/2020/11/19/Educational-Codeforces-Round-98-(Rated-for-Div.-2)/","datePublished":"2020-11-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/11/19/Educational-Codeforces-Round-98-(Rated-for-Div.-2)/"},"headline":"Educational Codeforces Round 98 (Rated for Div. 2)","description":"官方题解","dateModified":"2020-11-19T00:00:00+08:00","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" /><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="alternate" href="/feed.xml" title="RSS" type="application/rss+xml" /><link rel="apple-touch-icon-precomposed" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" /><link rel="shortcut icon" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=32" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/poole/lanyon@v1.1.0/public/css/poole.min.css,gh/poole/lanyon@v1.1.0/public/css/lanyon.min.css,gh/poole/lanyon@v1.1.0/public/css/syntax.min.css" /> <script async="async" src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/js/all.min.js" ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dreamer-Paul/Pio@2.4/static/pio.min.css" /><style> @media only print { .pio-container { display: none; } }</style><script async="async" src="https://cdn.jsdelivr.net/combine/gh/Dreamer-Paul/Pio@2.4/static/l2d.min.js,gh/Dreamer-Paul/Pio@2.4/static/pio.min.js" onload=' let pio_container = document.createElement("div"); pio_container.classList.add("pio-container"); pio_container.classList.add("right"); pio_container.style.bottom = "-2rem"; pio_container.style.zIndex = "1"; document.body.insertAdjacentElement("beforeend", pio_container); let pio_action = document.createElement("div"); pio_action.classList.add("pio-action"); pio_container.insertAdjacentElement("beforeend", pio_action); let pio_canvas = document.createElement("canvas"); pio_canvas.id = "pio"; pio_canvas.style.width = "14rem"; pio_canvas.width = "600"; pio_canvas.height = "800"; pio_container.insertAdjacentElement("beforeend", pio_canvas); let pio = new Paul_Pio({ "mode": "fixed", "hidden": true, "night": "for(let i=7; i<16; ++i) if(document.body.classList.contains(`theme-base-0`+i.toString(16))) { document.body.classList.remove(`theme-base-0`+i.toString(16)); document.body.classList.add(`theme-base-0`+((i-6)%9+7).toString(16)); break; }", "content": { "link": ["https:\/\/jekyll-theme-WuK.wu-kan.cn"], "skin": ["要换成我的朋友吗？", "让她放个假吧~"], "hidden": true, "custom": [{ "selector": "a", "type": "link", }, { "selector": ".sidebar-toggle", "text": "打开侧边栏叭~" }, { "selector": ".effect-info", "text": "哇，你发现了什么！" }, { "selector": "#sidebar-search-input", "text": "想搜索什么呢？很多干货哦！" }, { "selector": "#toc", "text": "这是目录~" }, { "selector": ".page-title", "text": "这是标题~" }, { "selector": ".v", "text": "评论没有审核，要对自己的发言负责哦~" }] }, "model": [ "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/33/model.2018.bls-winter.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/platelet-2/model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/xiaomai/xiaomai.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/mashiro/seifuku.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/Violet/14.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/Kobayaxi/Kobayaxi.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/mikoto/mikoto.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/uiharu/uiharu.model.json"] });' ></script> <script src='https://zz.bdstatic.com/linksubmit/push.js' async="async" ></script><style> .wrap { transition-property: width,background-size,transform; transition-duration: .3s; transition-timing-function: ease-in-out; min-height: 100%; display: inline-block; background-size: 100% auto; background-position: 0% 0%; background-repeat: no-repeat; background-attachment: fixed; background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/74559485_p1.webp); } @media (min-aspect-ratio: 2400/1850) { .wrap { background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/71932901_p0.webp); } } .sidebar-overlay #sidebar-checkbox:checked ~ .wrap { width: calc(100% - 14rem); background-size: calc(100% - 14rem) auto; transform: translateX(14rem); } .layout-reverse.sidebar-overlay #sidebar-checkbox:checked ~ .wrap { transform: translateX(0); }</style><style> .sidebar, html, h1, h2, h3, h4, h5, h6 { font-family: "Courier New", "Courier", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Microsoft YaHei Light", "Microsoft JhengHei", monospace; }</style><style> td, th { padding: 0px; border: 0px; } table { border: 0px; } table tbody { display: block; overflow: scroll; } table thead, tbody tr { display: table; table-layout: fixed; width: 100%; }</style><style> img { display: inline-block; margin: 0; }</style><style> ::-webkit-scrollbar { width: 3px; height: 3px; } ::-webkit-scrollbar-thumb { background-image: linear-gradient(45deg, Cyan 0%, Magenta 50%, Yellow 100%); }</style><style> ::selection { color: White; background: Black; }</style><body class="theme-base-0d layout-reverse sidebar-overlay"> <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. --> <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" /> <!-- Toggleable sidebar --><div class="sidebar" id="sidebar"><div class="sidebar-item"><div class="effect effect-right_to_left"> <img class="effect-img" src="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" alt="img" /><div class="effect-info"> SYSU超算17级在读<br/> 水野爱<br/> HPC<br/> 田宫例四驱车<br/> <a href="mailto:i@wu-kan.cn"> <i class="fas fa-envelope"></i> </a> <a href="https://github.com/wu-kan"> <i class="fab fa-github"></i> </a> <a href="https://codeforces.com/profile/WuK"> <i class="fas fa-chart-bar"></i> </a> <a href="https://vjudge.net/user/WuK"> <i class="fas fa-smile"></i> </a> <a href="https://www.zhihu.com/people/wu.kan/activities"> <i class="fab fa-zhihu"></i> </a> <iframe src="https://music.163.com/outchain/player?type=0&id=155059595&auto=0&height=32" width=100% height=52 frameborder="no" border="0" marginwidth="0" marginheight="0" ></iframe></div></div></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/"> <i class="fas fa-home fa-fw"></i> 首页 </a> <a class="sidebar-nav-item" href="/comments/"> <i class="fas fa-comments fa-fw"></i> 留言 </a> <a class="sidebar-nav-item" href="/tags/"> <i class="fas fa-tags fa-fw"></i> 标签 </a> <a class="sidebar-nav-item" href="/archive/"> <i class="fas fa-archive fa-fw"></i> 归档 </a> <a class="sidebar-nav-item" href="/merger/"> <i class="fas fa-coffee fa-fw"></i> 打赏 </a></nav><div class="sidebar-item"><style> #sidebar-search-input { background: none; border: none; color: White; width: 100%; } #sidebar-search-results-container { overflow: auto auto; max-height: 66.6vh; }</style><input id="sidebar-search-input" placeholder="搜索博文" /><ol id="sidebar-search-results-container" ></ol><script src='https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.9.1' async='async' onload=' SimpleJekyllSearch({ json: "/assets/simple-jekyll-search/search.json", searchInput: document.getElementById("sidebar-search-input"), resultsContainer: document.getElementById("sidebar-search-results-container"), searchResultTemplate: `<li><a href="{url}">{title}</a>`, limit: 999, fuzzy: true })' ></script><style> #toc { overflow: auto auto; max-height: 66.6vh; }</style><ol id="toc"><li><a href="#robot-program">Robot Program</a><li><a href="#toy-blocks">Toy Blocks</a><li><a href="#two-brackets">Two Brackets</a><li><a href="#radio-towers">Radio Towers</a><li><a href="#two-editorials">Two Editorials</a><li><a href="#divide-powers">Divide Powers</a><li><a href="#game-on-tree">Game On Tree</a></ol><style> .sidebar-checkbox { display: none; } .sidebar-toggle { position: fixed; }</style><style> .sidebar { overflow: scroll; min-height: 101%; }</style><style> .effect { margin: 1rem; perspective: 900px; } .effect-info { text-align: center; position: absolute; top: 0; transform-style: preserve-3d; } .effect-img { z-index: 11; width: 100%; height: 100%; position: relative; transition: all 0.5s ease-in-out; } .effect-img:before { position: absolute; display: block; } .effect-right_to_left .effect-img { transform-origin: 0% 50%; } .effect-right_to_left:hover .effect-img { transform: rotate3d(0, 1, 0, -180deg); }</style><div> <i class="fas fa-cog fa-spin fa-fw"></i> <span id="run_time_day"> <i class="fas fa-spinner fa-pulse"></i> </span>天 <span id="run_time_hour"> <i class="fas fa-spinner fa-pulse"></i> </span>时 <span id="run_time_minute"> <i class="fas fa-spinner fa-pulse"></i> </span>分 <span id="run_time_second"> <i class="fas fa-spinner fa-pulse"></i> </span>秒 <script> setInterval(function (d,h,m,s,b) { function setzero(i) { return i < 10 ? "0" + i : i; } let BirthDay = new Date(b); let today = new Date(); let timeold = (today.getTime() - BirthDay.getTime()); let sectimeold = timeold / 1000; let secondsold = Math.floor(sectimeold); let msPerDay = 24 * 60 * 60 * 1000; let e_daysold = timeold / msPerDay; let daysold = Math.floor(e_daysold); let e_hrsold = (e_daysold - daysold) * 24; let hrsold = Math.floor(e_hrsold); let e_minsold = (e_hrsold - hrsold) * 60; let minsold = Math.floor((e_hrsold - hrsold) * 60); let seconds = Math.floor((e_minsold - minsold) * 60); d.textContent = daysold; h.textContent = setzero(hrsold); m.textContent = setzero(minsold); s.textContent = setzero(seconds); }, 1000, document.getElementById("run_time_day"), document.getElementById("run_time_hour"), document.getElementById("run_time_minute"), document.getElementById("run_time_second"), "10/04/2017 11:03:56")// 这是我第一篇CSDN博客的时间 </script></div><div><div> <i class="fas fa-eye fa-fw"></i> <span id="busuanzi_value_page_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>次</div><div> <i class="fas fa-paw fa-fw"></i> <span id="busuanzi_value_site_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>枚</div><div> <i class="fas fa-user-friends fa-fw"></i> <span id="busuanzi_value_site_uv"> <i class="fas fa-spinner fa-pulse"></i> </span>人</div><script src='https://cdn.jsdelivr.net/npm/busuanzi@2.3.0' async='async' ></script></div><div> <i class="fas fa-thumbs-up fa-fw"></i> <a href="https://jekyll-theme-WuK.wu-kan.cn"> jekyll-theme-WuK </a></div><div> <i class="fas fa-copyright fa-fw"></i> 2017-2021 WuK</div><div> <i class="fas fa-info-circle fa-fw"></i> <a href="http://beian.miit.gov.cn"> 粤ICP备 20024947号 </a></div><div> <img src="https://i.loli.net/2021/03/17/Y47tDZTrcy2xwRa.png" class="fa-fw"></img> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=34070202000407"> 皖公网安备 34070202000407号 </a></div></div></div><!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --><div class="wrap"><style> @media only screen { pre { max-height: 66.6vh; overflow: auto; } }</style><style> .container { min-width: 66.6%; } @media only print { .container { min-width: 100%; } }</style><style> .container.content { padding: 2rem; box-shadow: 0 0 2rem rgba(255,255,255,0.9); background-color: rgba(255,255,255,0.9); animation-duration: 2s; animation-name: fadeIn; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }</style><div class="container content"><div class="page"><h1 class="page-title">Educational Codeforces Round 98 (Rated for Div. 2)</h1><div class="post"> <span class="post-date"> <i class="fas fa-calendar-day fa-fw"></i> 19 Nov 2020 <i class="fas fa-file-word fa-fw"></i> 6701字 <i class="fas fa-clock fa-fw"></i> 23分 <br/> <i class="fas fa-coffee fa-fw"></i> <a href="/merger/">如果这篇博客帮助到你，可以请我喝一杯咖啡~</a> <br/> <i class="fab fa-creative-commons-by fa-fw"></i> <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="license"> CC BY 4.0 </a> （除特别声明或转载文章外） </span><p><a href="https://codeforces.com/blog/entry/84847">官方题解</a></p><p>晚上闲着没事干，回来做一场，感觉全是要抖机灵的同一类题目，体 验 极 差</p><h2 id="robot-program"><a href="https://vjudge.net/problem/CodeForces-1452A">Robot Program</a></h2><p>实际意义上的 B 题。水题。</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int t, x, y;
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d%d", &amp;x, &amp;y);
		int p = min(x, y), q = max(x, y) - p;
		if (q)
			printf("%d\n", 2 * p + (q * 2 - 1));
		else
			printf("%d\n", 2 * p);
	}
}
</code></pre><h2 id="toy-blocks"><a href="https://vjudge.net/problem/CodeForces-1452B">Toy Blocks</a></h2><p>实际意义上的 C 题 or D 题？</p><p>赛场想法，分两类情况考虑：</p><ol><li>如果选择的不是最大的那一堆，那就用选择的一堆把其他堆补充到和最多的一堆相同，如有剩余则均分。<li>如果选择的是最大的那一堆，那就用选择的一堆把其他堆补充到和第二多的一堆相同，如有剩余则均分。</ol><p>这两类方法可以讨论出得到两个结果，但是赛场不敢确定是否取一个 max 就能过，犹豫再三，最后在结束前十几分钟交上去了，1A。我日。</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N = 2e5 + 9;
int t, n, a[N];
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%d", &amp;n);
		ll sum = 0, ans = 0, ans1 = 0;
		for (int i = 0; i &lt; n; ++i)
			scanf("%d", &amp;a[i]), sum += a[i];
		sort(a, a + n);

		if (ll(n - 1) * a[n - 2] &gt;= sum)
			ans1 = ll(n - 1) * a[n - 2] - sum;
		else
			ans1 = ((n - 1) - (sum - (ll(n - 1) * a[n - 2])) % (n - 1)) % (n - 1);

		if (ll(n - 1) * a[n - 1] &gt;= sum)
			ans = ll(n - 1) * a[n - 1] - sum;
		else
			ans = ((n - 1) - (sum - ll(n - 1) * a[n - 1]) % (n - 1)) % (n - 1);
		ans = max(ans, ans1);
		printf("%lld\n", ans);
	}
}
</code></pre><h2 id="two-brackets"><a href="https://vjudge.net/problem/CodeForces-1452C">Two Brackets</a></h2><p>实际意义上的 A 题。水题。</p><pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5 + 9;
int t;
char s[N];
int main()
{
	for (scanf("%d", &amp;t); t--;)
	{
		scanf("%s", s);
		int ans = 0;
		for (int i = 0, cnt0 = 0, cnt1 = 0; s[i]; ++i)
		{
			if (s[i] == '(')
				++cnt0;
			if (s[i] == ')' &amp;&amp; cnt0)
				--cnt0, ++ans;
			if (s[i] == '[')
				++cnt1;
			if (s[i] == ']' &amp;&amp; cnt1)
				--cnt1, ++ans;
		}
		printf("%d\n", ans);
	}
}
</code></pre><h2 id="radio-towers"><a href="https://vjudge.net/problem/CodeForces-1452D">Radio Towers</a></h2><p>因为第一塔的信号功率应完全等于覆盖之前的所有城镇所需的信号功率，第二塔的信号功率应完全等于在第一塔未覆盖的所有城镇之前覆盖的所有城镇所需的信号功率，等等。因此，让我们 DP 计算覆盖所有城镇的方法的数量（记为 $F_n$）：</p><ol><li>对于 $n\le 2$ 的答案显然；<li>对于 $n\ge 3,n\mod 2 = 0$，有 $F_n=F_1 + F_3 + \dots + F_{n - 1}$，又有 $F_1 + F_3 = 1 + 2 = F_4, F_4 + F_5 = F_6, \dots$，于是得到 $F_n=F_{n - 2} + F_{n - 1}$<li>对于 $n\ge 2,n\mod 2 = 1$，有 $F_n = 1 + F_2 + F_4 + F_6 + \dots + F_{n - 1}$，又有 $1 + F_2 = F_3,F_3 + F_4 = F_5,\dots$，剩下的同上。</ol><p>容易发现 $F_n$ 是斐波那契数列第 $n$ 项，于是答案是 $\frac{F_n}{2^n}$。</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef int ll;
const int N = 2e5 + 9;
struct Mod
{
	const ll M;
	Mod(ll M) : M(M) {}
	ll qadd(ll &amp;a, ll b) const { return a += b, a &gt;= M ? a -= M : a; } //假如a+b&lt;2*M，就不必取模了，取模运算耗时很高
	ll add(ll a, ll b) const { return qadd(a = (a + b) % M, M); }	   //考虑a和b不在同余系内甚至为负数的情况
	ll mul(long long a, ll b) const { return add(a * b % M, M); }
	ll inv(ll a) const { return pow(a, M - 2); } //要求M为素数，否则return pow(a, phi(M) - 1);
	ll pow(ll a, ll b) const
	{
		ll r = 1;
		if (b &lt; 0)
			b = -b, a = inv(a);
		for (a = add(a, M); b; b &gt;&gt;= 1, a = mul(a, a))
			if (b &amp; 1)
				r = mul(r, a);
		return r;
	}
} M(998244353);
int n, f[N] = {0, 1};
int main()
{
	for (int i = 2; i &lt; N; ++i)
		M.qadd(f[i] = f[i - 1], f[i - 2]);
	scanf("%d", &amp;n);
	printf("%d", M.mul(f[n], M.pow(2, -n)));
}
</code></pre><p><del>据说现场打表很容易猜到答案…但是孤儿 B 题把我时间都搞完了…</del></p><h2 id="two-editorials"><a href="https://vjudge.net/problem/CodeForces-1452E">Two Editorials</a></h2><p>好题。$m$ 个参赛者，$n$ 道题目，两个讲题人各讲一次题，每次讲题讲编号连续的 $k$ 道题（两个人讲题区间可以相交也可以不交，同时区间的并集不需要是全集）。第 $i$ 个参赛者对题目 $\left[L_i,R_i\right]$ 感兴趣，但是只会去听感兴趣题目最多的一次讲题，听到的感兴趣的题目数是 $a_i$，现在要安排两个讲题人的讲题区间，使 $\sum_{i=1}^ma_i$ 最大化。</p><p>考虑一个命题人的讲题区间 $\left[i,i+k-1\right]$ 随着 $i$ 的增加落在 $\left[L_i,R_i\right]$ 的情况，必然是一个对称的先增后减过程，在中点处达到最值。因此将所有区间按照其中点 $\frac{L_i+R_i}{2}$ 排序考虑，容易用反证法证明存在一个分点，最优方案一定是所有中点小于这个分点的区间分给一个命题人，其他的分给另外一个讲题人。</p><p>于是枚举 $m+1$ 个分点即可，时间复杂度 $O(n\log n+nm)$。</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int n, m, k;
	scanf("%d%d%d", &amp;n, &amp;m, &amp;k);
	vector&lt;pair&lt;int, int&gt;&gt; a(m);
	for (int i = 0; i &lt; m; ++i)
	{
		scanf("%d%d", &amp;a[i].first, &amp;a[i].second);
		a[i].first += a[i].second - 1;
	}
	sort(a.begin(), a.end());
	vector&lt;int&gt; su(m + 1);
	for (int i = 0; i &lt; n - k + 1; ++i)
		for (int j = m - 1, cur = 0; j &gt;= 0; --j)
		{
			cur += max(0, min(i + k, a[j].second) - max(i, a[j].first - a[j].second));
			su[j] = max(su[j], cur);
		}
	int ans = su[0];
	for (int i = 0; i &lt; n - k + 1; ++i)
		for (int j = 0, cur = 0; j &lt; m; ++j)
		{
			cur += max(0, min(i + k, a[j].second) - max(i, a[j].first - a[j].second));
			ans = max(ans, cur + su[j + 1]);
		}
	printf("%d", ans);
}
</code></pre><p>据说 $O(n^2m)$ 的暴力打开向量化也可过…CF 机器这么快的吗…</p><p><img src="https://codeforces.com/predownloaded/7b/38/7b387fd54f6af06870062fc3457981afc3db1ce8.jpg" alt="向量化牛逼" /></p><h2 id="divide-powers"><a href="https://vjudge.net/problem/CodeForces-1452F">Divide Powers</a></h2><p>对于每个操作 2，实际上有了两类选择：</p><ol><li>选择一个本来就符合条件的元素分解，使符合要求的元素 +1；<li>选择一个本来不符合条件的元素分解，使符合要求的元素 +2（分界点上）或 +0；</ol><p>由于要操作数最小，于是贪心地选择性价比更高的第二类操作（且显然优先选小的元素不会让结果变得更差），剩余的使用第一类补齐即可。</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll n, q;
int main()
{
	scanf("%lld%lld", &amp;n, &amp;q);
	vector&lt;ll&gt; a(n);
	for (ll i = 0; i &lt; n; ++i)
		scanf("%lld", &amp;a[i]);
	for (ll j = 0, t, x, k; j &lt; q; ++j)
	{
		scanf("%lld%lld%lld", &amp;t, &amp;x, &amp;k);
		if (t == 1)
		{
			a[x] = k;
			continue;
		}
		vector&lt;ll&gt; b(a);
		ll ret = 0, cnt = 0;
		for (ll i = 0; i &lt;= x; ++i)
			cnt += b[i];
		while (cnt &lt; k)
		{
			for (ll i = x + 1; i &lt; n; ++i)
			{
				ll s = min(b[i], (k - cnt) / (1LL &lt;&lt; (i - x)));
				ret += s * ((1LL &lt;&lt; (i - x)) - 1);
				cnt += s * (1LL &lt;&lt; (i - x));
				b[i] -= s;
				b[x] += s * (1LL &lt;&lt; (i - x));
			}
			ll sum = 0;
			for (ll i = 0; i &lt;= x; ++i)
				sum += b[i] &lt;&lt; i;
			if (sum &gt;= k)
			{
				ret += k - cnt;
				break;
			}
			ll loc = x + 1;
			while (loc &lt; n &amp;&amp; b[loc] == 0)
				++loc;
			if (loc == n)
			{
				ret = -1;
				break;
			}
			ret += loc - x;
			cnt += 2;
			b[x] += 2;
			for (ll i = x + 1; i &lt; loc; ++i)
				++b[i];
		}
		printf("%lld\n", ret);
	}
}
</code></pre><p><del>大锤八十砸墙，小锤四十扣缝</del></p><h2 id="game-on-tree"><a href="https://vjudge.net/problem/CodeForces-1452G">Game On Tree</a></h2><p>树上分治。直接贴官方题解稍改一下的代码。</p><pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5 + 9, INF = 1e9;
vector&lt;int&gt; g[N], dist[N];
int sz[N], par[N], used[N], max_dist[N];
int calc_size(int x, int p = -1)
{
	sz[x] = 1;
	for (auto y : g[x])
		if (y != p &amp;&amp; !used[y])
			sz[x] += calc_size(y, x);
	return sz[x];
}
int find_centroid(int x, int p, int s)
{
	int ans = -1;
	bool good = true;
	for (auto y : g[x])
		if (y != p &amp;&amp; !used[y])
			good &amp;= sz[y] * 2 &lt;= s;
		else if (y == p &amp;&amp; !used[y])
			good &amp;= (s - sz[x]) * 2 &lt;= s;
	if (good)
		ans = x;
	for (auto y : g[x])
		if (y != p &amp;&amp; !used[y])
			ans = max(ans, find_centroid(y, x, s));
	return ans;
}
void calc_dist(int x, int p, int d, int s)
{
	dist[x].push_back(d);
	for (auto y : g[x])
		if (y != p &amp;&amp; !used[y])
			calc_dist(y, x, d + 1, s);
	max_dist[s] = max(max_dist[s], d);
}
int decomposition(int v)
{
	calc_size(v);
	int c = find_centroid(v, v, sz[v]);
	used[c] = true;
	for (auto y : g[c])
		if (!used[y])
			par[decomposition(y)] = c;
	used[c] = false;
	calc_dist(c, c, 0, c);
	return c;
}
int main()
{
	int n, k;
	scanf("%d", &amp;n);
	for (int i = 0, x, y; i &lt; n - 1; i++)
	{
		scanf("%d %d", &amp;x, &amp;y);
		g[--x].push_back(--y);
		g[y].push_back(x);
	}
	scanf("%d", &amp;k);
	vector&lt;int&gt; d(n, INF);
	{
		deque&lt;int&gt; q;
		for (int i = 0, x; i &lt; k; ++i)
		{
			scanf("%d", &amp;x);
			q.push_back(--x);
			d[x] = 0;
		}
		while (!q.empty())
		{
			int x = q.front();
			q.pop_front();
			for (auto y : g[x])
				if (d[y] &gt; d[x] + 1)
				{
					q.push_back(y);
					d[y] = d[x] + 1;
				}
		}
	}
	decomposition(0);
	vector&lt;vector&lt;int&gt;&gt; val;
	for (int i = 0; i &lt; n; ++i)
		val.emplace_back(max_dist[i] + 1, 0);
	for (int i = 0; i &lt; n; ++i)
		if (d[i])
			for (int curc = i, j = 0; j &lt; dist[i].size(); ++j)
			{
				int dd = dist[i][j];
				if (dd &gt; d[i] - 1)
				{
					curc = par[curc];
					continue;
				}
				dd = d[i] - 1 - dd;
				if (dd &gt;= val[curc].size())
					dd = val[curc].size() - 1;
				val[curc][dd] = max(val[curc][dd], d[i]);
				curc = par[curc];
			}
	for (int i = 0; i &lt; n; ++i)
		for (int j = max_dist[i]; j &gt;= 1; --j)
			val[i][j - 1] = max(val[i][j], val[i][j - 1]);
	for (int i = 0; i &lt; n; ++i)
	{
		int ans = 0;
		for (int curc = i, j = 0; j &lt; dist[i].size(); ++j)
		{
			int dd = dist[i][j];
			ans = max(ans, val[curc][dd]);
			curc = par[curc];
		}
		printf("%d ", d[i] ? ans : 0);
	}
}
</code></pre></div><script repo="wu-kan/utterances-storage" src="https://utteranc.es/client.js" issue-term="url" theme="github-light" crossorigin="anonymous" async="async" ></script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" /><style> .katex-display>.katex { white-space: normal; }</style><script src="https://cdn.jsdelivr.net/combine/npm/katex@0.13.11/dist/katex.min.js,npm/katex@0.13.11/dist/contrib/auto-render.min.js" async="async" onload='renderMathInElement(document.body, { delimiters: [{left: "$$", right: "$$", display: true}, { left: "$", right: "$", display: false }, {left: "\\(", right: "\\)", display: false}, {left: "\\[", right: "\\]", display: true}]})' ></script><style> pre.language-mermaid, code.language-mermaid { display: none; } @media only screen { .mermaid { overflow: auto auto; max-width: 100%; max-height: 66.6vh; } }</style><script src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" async="async" onload=' for(let x of document.getElementsByClassName("language-mermaid")) if(x.nodeName=="CODE") { let m = document.createElement("div"); m.classList.add("mermaid"); m.textContent = x.textContent; x.parentNode.insertAdjacentElement("beforebegin", m); }' ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.css,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.css,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.css,npm/prism-themes@1.5.0/themes/prism-nord.min.css" /> <script src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/components/prism-core.min.js,npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js,npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.js,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.js" async="async" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/" onload=' for(let x of document.getElementsByClassName("content")) x.classList.add("line-numbers","match-braces"); Prism.plugins.toolbar.registerButton("select-code", function (env) { let button = document.createElement("button"); button.textContent = "select this " + env.language; button.addEventListener("click", function () { if (document.body.createTextRange) { let range = document.body.createTextRange(); range.moveToElementText(env.element); range.select(); } else if (window.getSelection) { let selection = window.getSelection(); let range = document.createRange(); range.selectNodeContents(env.element); selection.removeAllRanges(); selection.addRange(range); } }); return button; })' ></script></div><label for="sidebar-checkbox" class="sidebar-toggle"></label>
