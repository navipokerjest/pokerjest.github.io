<!DOCTYPE html><html><head><title> 使用词法分析器 Flex 提取程序中的整数和浮点数 &middot; wu-kan</title><!-- Begin Jekyll SEO tag v2.7.1 --><meta name="generator" content="Jekyll v3.9.0" /><meta property="og:title" content="使用词法分析器 Flex 提取程序中的整数和浮点数" /><meta property="og:locale" content="en_US" /><meta name="description" content="SYSU超算17级在读 水野爱 HPC 田宫例四驱车 &lt;iframe src=”https://music.163.com/outchain/player?type=0&amp;id=155059595&amp;auto=0&amp;height=32” width=100% height=52 frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” &lt;/iframe&gt;" /><meta property="og:description" content="SYSU超算17级在读 水野爱 HPC 田宫例四驱车 &lt;iframe src=”https://music.163.com/outchain/player?type=0&amp;id=155059595&amp;auto=0&amp;height=32” width=100% height=52 frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” &lt;/iframe&gt;" /><link rel="canonical" href="http://localhost:4000/2020/05/14/%E4%BD%BF%E7%94%A8%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-Flex-%E6%8F%90%E5%8F%96%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/" /><meta property="og:url" content="http://localhost:4000/2020/05/14/%E4%BD%BF%E7%94%A8%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-Flex-%E6%8F%90%E5%8F%96%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/" /><meta property="og:site_name" content="wu-kan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-05-14T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="使用词法分析器 Flex 提取程序中的整数和浮点数" /><meta name="google-site-verification" content="YIKi1rBnyUaS-DMYiluseI5kZzTwjCkTFmKkSkMZDJk" /><meta name="baidu-site-verification" content="szbTSfUGAB" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"http://localhost:4000/2020/05/14/%E4%BD%BF%E7%94%A8%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-Flex-%E6%8F%90%E5%8F%96%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/","datePublished":"2020-05-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/05/14/%E4%BD%BF%E7%94%A8%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-Flex-%E6%8F%90%E5%8F%96%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/"},"headline":"使用词法分析器 Flex 提取程序中的整数和浮点数","description":"SYSU超算17级在读 水野爱 HPC 田宫例四驱车 &lt;iframe src=”https://music.163.com/outchain/player?type=0&amp;id=155059595&amp;auto=0&amp;height=32” width=100% height=52 frameborder=”no” border=”0” marginwidth=”0” marginheight=”0” &lt;/iframe&gt;","dateModified":"2020-05-14T00:00:00+08:00","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1" /><meta http-equiv="content-type" content="text/html; charset=utf-8" /><link rel="alternate" href="/feed.xml" title="RSS" type="application/rss+xml" /><link rel="apple-touch-icon-precomposed" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" /><link rel="shortcut icon" href="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=32" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/poole/lanyon@v1.1.0/public/css/poole.min.css,gh/poole/lanyon@v1.1.0/public/css/lanyon.min.css,gh/poole/lanyon@v1.1.0/public/css/syntax.min.css" /> <script async="async" src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/js/all.min.js" ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dreamer-Paul/Pio@2.4/static/pio.min.css" /><style> @media only print { .pio-container { display: none; } }</style><script async="async" src="https://cdn.jsdelivr.net/combine/gh/Dreamer-Paul/Pio@2.4/static/l2d.min.js,gh/Dreamer-Paul/Pio@2.4/static/pio.min.js" onload=' let pio_container = document.createElement("div"); pio_container.classList.add("pio-container"); pio_container.classList.add("right"); pio_container.style.bottom = "-2rem"; pio_container.style.zIndex = "1"; document.body.insertAdjacentElement("beforeend", pio_container); let pio_action = document.createElement("div"); pio_action.classList.add("pio-action"); pio_container.insertAdjacentElement("beforeend", pio_action); let pio_canvas = document.createElement("canvas"); pio_canvas.id = "pio"; pio_canvas.style.width = "14rem"; pio_canvas.width = "600"; pio_canvas.height = "800"; pio_container.insertAdjacentElement("beforeend", pio_canvas); let pio = new Paul_Pio({ "mode": "fixed", "hidden": true, "night": "for(let i=7; i<16; ++i) if(document.body.classList.contains(`theme-base-0`+i.toString(16))) { document.body.classList.remove(`theme-base-0`+i.toString(16)); document.body.classList.add(`theme-base-0`+((i-6)%9+7).toString(16)); break; }", "content": { "link": ["https:\/\/jekyll-theme-WuK.wu-kan.cn"], "skin": ["要换成我的朋友吗？", "让她放个假吧~"], "hidden": true, "custom": [{ "selector": "a", "type": "link", }, { "selector": ".sidebar-toggle", "text": "打开侧边栏叭~" }, { "selector": ".effect-info", "text": "哇，你发现了什么！" }, { "selector": "#sidebar-search-input", "text": "想搜索什么呢？很多干货哦！" }, { "selector": "#toc", "text": "这是目录~" }, { "selector": ".page-title", "text": "这是标题~" }, { "selector": ".v", "text": "评论没有审核，要对自己的发言负责哦~" }] }, "model": [ "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/33/model.2018.bls-winter.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/platelet-2/model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/xiaomai/xiaomai.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/mashiro/seifuku.model.json", "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/Violet/14.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/Kobayaxi/Kobayaxi.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/mikoto/mikoto.model.json", "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/uiharu/uiharu.model.json"] });' ></script> <script src='https://zz.bdstatic.com/linksubmit/push.js' async="async" ></script><style> .wrap { transition-property: width,background-size,transform; transition-duration: .3s; transition-timing-function: ease-in-out; min-height: 100%; display: inline-block; background-size: 100% auto; background-position: 0% 0%; background-repeat: no-repeat; background-attachment: fixed; background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/74559485_p1.webp); } @media (min-aspect-ratio: 2400/1850) { .wrap { background-image: url(https://Mizuno-Ai.wu-kan.cn/pixiv/71932901_p0.webp); } } .sidebar-overlay #sidebar-checkbox:checked ~ .wrap { width: calc(100% - 14rem); background-size: calc(100% - 14rem) auto; transform: translateX(14rem); } .layout-reverse.sidebar-overlay #sidebar-checkbox:checked ~ .wrap { transform: translateX(0); }</style><style> .sidebar, html, h1, h2, h3, h4, h5, h6 { font-family: "Courier New", "Courier", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Microsoft YaHei Light", "Microsoft JhengHei", monospace; }</style><style> td, th { padding: 0px; border: 0px; } table { border: 0px; } table tbody { display: block; overflow: scroll; } table thead, tbody tr { display: table; table-layout: fixed; width: 100%; }</style><style> img { display: inline-block; margin: 0; }</style><style> ::-webkit-scrollbar { width: 3px; height: 3px; } ::-webkit-scrollbar-thumb { background-image: linear-gradient(45deg, Cyan 0%, Magenta 50%, Yellow 100%); }</style><style> ::selection { color: White; background: Black; }</style><body class="theme-base-0d layout-reverse sidebar-overlay"> <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular styles, `#sidebar-checkbox` for behavior. --> <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox" /> <!-- Toggleable sidebar --><div class="sidebar" id="sidebar"><div class="sidebar-item"><div class="effect effect-right_to_left"> <img class="effect-img" src="https://gravatar.loli.net/avatar/289efba375d63424de3c49569c446744?s=320" alt="img" /><div class="effect-info"> SYSU超算17级在读<br/> 水野爱<br/> HPC<br/> 田宫例四驱车<br/> <a href="mailto:i@wu-kan.cn"> <i class="fas fa-envelope"></i> </a> <a href="https://github.com/wu-kan"> <i class="fab fa-github"></i> </a> <a href="https://codeforces.com/profile/WuK"> <i class="fas fa-chart-bar"></i> </a> <a href="https://vjudge.net/user/WuK"> <i class="fas fa-smile"></i> </a> <a href="https://www.zhihu.com/people/wu.kan/activities"> <i class="fab fa-zhihu"></i> </a> <iframe src="https://music.163.com/outchain/player?type=0&id=155059595&auto=0&height=32" width=100% height=52 frameborder="no" border="0" marginwidth="0" marginheight="0" ></iframe></div></div></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/"> <i class="fas fa-home fa-fw"></i> 首页 </a> <a class="sidebar-nav-item" href="/comments/"> <i class="fas fa-comments fa-fw"></i> 留言 </a> <a class="sidebar-nav-item" href="/tags/"> <i class="fas fa-tags fa-fw"></i> 标签 </a> <a class="sidebar-nav-item" href="/archive/"> <i class="fas fa-archive fa-fw"></i> 归档 </a> <a class="sidebar-nav-item" href="/merger/"> <i class="fas fa-coffee fa-fw"></i> 打赏 </a></nav><div class="sidebar-item"><style> #sidebar-search-input { background: none; border: none; color: White; width: 100%; } #sidebar-search-results-container { overflow: auto auto; max-height: 66.6vh; }</style><input id="sidebar-search-input" placeholder="搜索博文" /><ol id="sidebar-search-results-container" ></ol><script src='https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.9.1' async='async' onload=' SimpleJekyllSearch({ json: "/assets/simple-jekyll-search/search.json", searchInput: document.getElementById("sidebar-search-input"), resultsContainer: document.getElementById("sidebar-search-results-container"), searchResultTemplate: `<li><a href="{url}">{title}</a>`, limit: 999, fuzzy: true })' ></script><style> #toc { overflow: auto auto; max-height: 66.6vh; }</style><ol id="toc"><li><a href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83">实验环境</a><li><a href="#%E5%AE%9E%E9%AA%8C%E5%8E%9F%E7%90%86">实验原理</a><ol><li><a href="#%E9%9C%80%E8%A6%81%E8%B7%B3%E8%BF%87%E7%9A%84%E5%86%85%E5%AE%B9">需要跳过的内容</a><li><a href="#%E6%95%B4%E6%95%B0">整数</a><li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></ol><li><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">实验过程</a><ol><li><a href="#%E6%BA%90%E4%BB%A3%E7%A0%81-lexl">源代码 lex.l</a><li><a href="#%E7%94%9F%E6%88%90-lexyyc">生成 lex.yy.c</a><li><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-screenlog">运行结果 screen.log</a></ol><li><a href="#%E5%AE%9E%E9%AA%8C%E5%BF%83%E5%BE%97">实验心得</a></ol><style> .sidebar-checkbox { display: none; } .sidebar-toggle { position: fixed; }</style><style> .sidebar { overflow: scroll; min-height: 101%; }</style><style> .effect { margin: 1rem; perspective: 900px; } .effect-info { text-align: center; position: absolute; top: 0; transform-style: preserve-3d; } .effect-img { z-index: 11; width: 100%; height: 100%; position: relative; transition: all 0.5s ease-in-out; } .effect-img:before { position: absolute; display: block; } .effect-right_to_left .effect-img { transform-origin: 0% 50%; } .effect-right_to_left:hover .effect-img { transform: rotate3d(0, 1, 0, -180deg); }</style><div> <i class="fas fa-cog fa-spin fa-fw"></i> <span id="run_time_day"> <i class="fas fa-spinner fa-pulse"></i> </span>天 <span id="run_time_hour"> <i class="fas fa-spinner fa-pulse"></i> </span>时 <span id="run_time_minute"> <i class="fas fa-spinner fa-pulse"></i> </span>分 <span id="run_time_second"> <i class="fas fa-spinner fa-pulse"></i> </span>秒 <script> setInterval(function (d,h,m,s,b) { function setzero(i) { return i < 10 ? "0" + i : i; } let BirthDay = new Date(b); let today = new Date(); let timeold = (today.getTime() - BirthDay.getTime()); let sectimeold = timeold / 1000; let secondsold = Math.floor(sectimeold); let msPerDay = 24 * 60 * 60 * 1000; let e_daysold = timeold / msPerDay; let daysold = Math.floor(e_daysold); let e_hrsold = (e_daysold - daysold) * 24; let hrsold = Math.floor(e_hrsold); let e_minsold = (e_hrsold - hrsold) * 60; let minsold = Math.floor((e_hrsold - hrsold) * 60); let seconds = Math.floor((e_minsold - minsold) * 60); d.textContent = daysold; h.textContent = setzero(hrsold); m.textContent = setzero(minsold); s.textContent = setzero(seconds); }, 1000, document.getElementById("run_time_day"), document.getElementById("run_time_hour"), document.getElementById("run_time_minute"), document.getElementById("run_time_second"), "10/04/2017 11:03:56")// 这是我第一篇CSDN博客的时间 </script></div><div><div> <i class="fas fa-eye fa-fw"></i> <span id="busuanzi_value_page_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>次</div><div> <i class="fas fa-paw fa-fw"></i> <span id="busuanzi_value_site_pv"> <i class="fas fa-spinner fa-pulse"></i> </span>枚</div><div> <i class="fas fa-user-friends fa-fw"></i> <span id="busuanzi_value_site_uv"> <i class="fas fa-spinner fa-pulse"></i> </span>人</div><script src='https://cdn.jsdelivr.net/npm/busuanzi@2.3.0' async='async' ></script></div><div> <i class="fas fa-thumbs-up fa-fw"></i> <a href="https://jekyll-theme-WuK.wu-kan.cn"> jekyll-theme-WuK </a></div><div> <i class="fas fa-copyright fa-fw"></i> 2017-2021 WuK</div><div> <i class="fas fa-info-circle fa-fw"></i> <a href="http://beian.miit.gov.cn"> 粤ICP备 20024947号 </a></div><div> <img src="https://i.loli.net/2021/03/17/Y47tDZTrcy2xwRa.png" class="fa-fw"></img> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=34070202000407"> 皖公网安备 34070202000407号 </a></div></div></div><!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --><div class="wrap"><style> @media only screen { pre { max-height: 66.6vh; overflow: auto; } }</style><style> .container { min-width: 66.6%; } @media only print { .container { min-width: 100%; } }</style><style> .container.content { padding: 2rem; box-shadow: 0 0 2rem rgba(255,255,255,0.9); background-color: rgba(255,255,255,0.9); animation-duration: 2s; animation-name: fadeIn; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }</style><div class="container content"><div class="page"><h1 class="page-title">使用词法分析器 Flex 提取程序中的整数和浮点数</h1><div class="post"> <span class="post-date"> <i class="fas fa-calendar-day fa-fw"></i> 14 May 2020 <i class="fas fa-file-word fa-fw"></i> 60450字 <i class="fas fa-clock fa-fw"></i> 202分 <br/> <i class="fas fa-coffee fa-fw"></i> <a href="/merger/">如果这篇博客帮助到你，可以请我喝一杯咖啡~</a> <br/> <i class="fab fa-creative-commons-by fa-fw"></i> <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="license"> CC BY 4.0 </a> （除特别声明或转载文章外） </span><p><img src="data:image/webp;base64,UklGRvAKAABXRUJQVlA4IOQKAACwXQCdASp7CD8AP73a524+M7EqIpDJk8A3iWdu/C45q+stXcVX8pf67uE8Ba/A3N/Od+u6xvFQy+V4t5aeQhvMp398hPpLdmX2HdIvfJrLKqv7IPJKFS75w5FVX9kHklCpd84ciqr+yDyShUu+cORVV/ZB5JQqXfOHIqq/sg8koVLvnDkVVf2QeR9ykT9h7lVyMeLbhJUgirEuKFaDrBKaWOxhHk0+3STNyHLquDNya0JqL5jyVjoQeDB9V/6gawQUsWX6DUz9sZnTV0XouVdwO0D8uAYEqi4ELyP8RjeK35x2WVUtASZ2eBNB0ET1g/6mXjUOVNct/Pt5tlrn/Cn6FsN0MoiqqmB6+1cSkHDrjjKnssVn3dI68P4xoOajt3xk41+C2h//TTe+TWNm3/U2artWvJKFS75w5EplJa66X1GJnYKARu1kb9bujtbqKqnkkzoijO7IPHMmVS9ko+v7IOclzzVQaQvDjU4ciUyb2YdTaQbQdV03eTaAFfjd/42vzkWuJuqupAbEJn4uHYyMn7c2ojbx17ZARqf3BNuDyRv7sKJ7WsICkwxs8OZOxGLNLyAjSnakvOFLRNia9Wn6QKf6d2h5CQEo3DRJtiOXYC8ORVV+b6nePyVJTBxkNFQpL+J8KCyaqmdFiLsUZ3RXgpDzl3oSWeGSpALWzvAajw7rTThWiWZ9Oi2ChwIDqUIoUzO81CmMKaamssl2LZibUyUXsbywVM5HvJKE/QCVCVOmAHspML96hFVX9kHkkiLy7CD/t0CL2Cf73J/ZsBMKhSQj31wGRmxGwDMIiKzjSrSkDb5QOi7mTPEMnQsx+WcdFLP9sszSfBM9cJjxyKquUEUcGDjurRwBmRFfYNSKquVAm84Z6c/b8xQr6/XE6QAq+kJRei77EuB/G54CG8WHprScwxq98mss/o5dc75w5FVbd0EBv7IPKAHt3yayyrFPZB5JQqXfOHIqq/sg8koVL1h3sLvnDkVVf2QerPZB5JQqXrBUAAD9ROCdD2T18FFH2lrUas4XmWyYWK/W7Pg+AAAAA2j4V2FIVUqssQ6ZyrdMtC7RaUTbRCexI9FSeIMNrsysckAhhkgsRa++TvPzn6gtoF5Fk5gARFyKfzS25ZEmfO1ugpgbt9oDirYP6hc3IrUHRrOZl8c8BXr3SCXosP0fILaZrsh4Ous07a6siLszRtepUNM55UwX6YiFenOaw9Y37AAqzN18uFgJ3EyEmc9dvIS5swKldP+P4R2KL9oT7vcjlE4Ikj6tWCs+Lch6gUHJ5+DDRYLmv/M2Z2DFNZvHZW+QOCpsdeWEUu4sqQc9/WAK+81yQEIc4te6gf3JKdylbd6MHsomRNPGJSr547sfrRnV9PaVAxTeAa8TiGc9iXCxR5s0GmAzn9fyZOfM5G8OVFa5ORJmNyVCoUHqDyEhdXUSTFnKuqlFDsII+c+HPBkhPGfjiVIxfmcjHLGFGIHnSbv7mZwMk+0Ct10aq9t6G05IjSRHn3v9gwnN51lJ9UMPd6wHWjCJI42qbzJMkP2KhVtOMYxYZoc+fyWFKii+vjWfXCS7OcPZEh+BKSKO6Y441Afq2isJmcsjKqsPuESp6eNJeOVy2MW90aQWjkuOQ/GzLRN0S/BQy2soKLzUzSP+bTeH/qdRurKEKR8T3zNy6OGyTZw9jn4oh8+OSVqx+BKSKO6lWwIF78h9uB8lwW4YQe6uYb6/PmawV5/Iy/FHn4akoIQSlrfjWRYQou9ALfw9au8Sa3ddDSHQcnoN1Jy5nnXJYDiFbDvmYeXn8XbyBlRySm+IZ/wYwx8vaZcsu5n6RaUOJVku3BYzPty67k6dQD2pxYQowIYyWkhvyHVk3fzbCWL11ntdNw7mxlQpdt2iUDR2k1CD0zk313yQtOr2DAjxTlEhO2qB2xY71XmI/NlCVOKyZitDOjcYxmNz8NHe95QdRwcNXcDkspmRd1aUhTBipTqAdIOMXYdTW2Y916NEvXhtQcn6YrVgYb4kHwvkURuF1e4hc+AVsJxElM3nVEBxs/gL4wG2SaM8DqPznk65DdmSnrdS1KVS9GyqpCOChmrmfbAYkCe/YK1e9JVv3Q+RjINhBeXGtUpLPZp4ImijeXlA841o7fSLP1I3VIxFRS2ExihvbHYkN+AywEsFC+lQHqmgtEFXH6mhZHa3H5qqoQAhyaWZqIFqlru1lQOJSWi/BVhMN4ivwZhu2DW1u05DzFXFPsI+3RgBL9XB40jmHLK1UtE9GAB4iB6rbgb06grjZd0cxNRrumb4SidytCNErBusltFsEn5IAkzGmfvQhlVEcVO/vl+xvDO+oZgK1PHm0XUYig8WxIjqu1BYHUq0jRtuAKfV4EBA+Oz2jGUNftpVW6kFMZ4U+CDN9of0otW95B3d7A2W9ITDCbyHvc6jLeCtxXEIuZU2foFXNMlUK3kljY37Wr4bOk2ape/VUW2AAJY0I1VT2vXI7fKBjqmoY+bsgZ20LEKga/sCuFP4tPZpnf/IyxRBsKsuOaHLBVLyq0q45djEZZ7JYgRIYwfwviUEqKt6O1sOKjCLWDnWuwfk0DY2rX3rhzRgQ1QI3YTaYUxTgJCsRzWuZ/VPeiiqYX0g0BPI6kkYmDR+l/piCRA5qvskkQUm9cfWONldZDKPT2TYbJ6qGM764CeJ7diqr0nuoteNWI25JXWfT7yO+Vexqf6icdW7J0JIIxxZT7C9ltstmuB436wlG2rFc64YmWVW7QHuvGMsGwjeW8QWUL6i1Fw7qvjA5luUf0fA724y+teEOmbOjQNE+M01yZUHFVsLLgEvJQCVjNdBMffcTv0wrDl+R/9ocWtqlAMQPd+E+bhSL+XCgDSZpmwCBx6vv7WrtsjLLKQL8X4T/GAahcbind4Pv4sWFFswBXrwImYe/D54dUA5d6K6F6tKnpbgqQcgFCr3JYS0TSGj94wgxh4FgDCJEQ1nwQS0EKNsIc5pnNC1GwBcdcjG+aLe46ufCPjpC5Abmn3Kjf4HEEY3Csx+QAgezWq/uZKy2O0XvlgDwMptQXM4G1HvhZUT7X8mWULL4RRB7obU4oG6AGKTtxfd8tr/F++LhJ1gzAR+KfY0RvCfdYJPC3ia3tyvrISM0P69m5yM2f39VOw6G7r6brsViI7Xh0FKV6hL8tEWp/XDx3F+JJdWx5kBLlRiEREFGiVDyF7HpC0OTj4wDsur7uVFaTS/15Q+WTDnNVgX7pnithOmf5cmADn41w2WVUz059/4iSWaHVPjwjTLoqsiLZ0OslrGqxZw/7mmzELF8FBe9VMVPrp1xO5Z/BOb9INlkCMJkQepZvjwcrLsBVt3hD94VsyAeCwHVC5nPE2eiekCjLrVEU0bkwcYIP24ems8uSMEYC/KKX59zcDpRnMS9c2KkyjNtIOtmWbU5wOp80fwolN8OifHJu9Jrpokr/65ICXYmFnvBiWsCFwKsOSQ3FvPENdzzAnxUdWeXEOUb7slb7KkfUx98eR8+/WoEbdIsm3kDHJM0uNyuSov77GRg9hSlGax/VzlaPEKPQhkGn01vVuU4/pIMyQFU3sB7gAgEn324Ki0rj7dGYD/kkmRsasU06LaQhwj+50et6sxlBOg2hwT41tI4qJaKA6EOmYvrAgVkJ5MZYl+qK7Zhwu5JRJx252amfjmCWyMtjpWpp3KhJ16cjRDWgkZbiJPhlKv7VPrmYUAAAAAAAAA" alt="成绩" /></p><p>Flex 是一个生成词法分析器的工具，它可以利用正则表达式来生成匹配相应字符串的 C 语言代码，其语法格式基本同 Lex 相同。本文基于 Flex 实现下面的功能：</p><p>输入一个合法的 C/C++ 程序，提取程序中的整数和浮点数，并统计各自出现的次数。注意像变量名或函数名中包含的数字不应统计进去。实验加分项：忽略掉注释里面的整数和浮点数。</p><ul><li><a href="https://www.geeksforgeeks.org/flex-fast-lexical-analyzer-generato">Flex 简要介绍</a><li><a href="http://westes.github.io/flex/manual/index.html#SEC_Contents">Flex 官方手册</a></ul><h2 id="实验环境">实验环境</h2><ul><li>Windows 10 1909, 64-bit 18363.836<ul><li>Visual Studio Code 1.45.0<ul><li>Remote - WSL 0.44.2：配合 WSL，在 Windows 上获得 Linux 接近原生环境的体验。</ul><li>Windows Subsystem for Linux [Ubuntu 18.04.2 LTS]：WSL 是以软件的形式运行在 Windows 下的 Linux 子系统，是近些年微软推出来的新工具，可以在 Windows 系统上原生运行 Linux。<ul><li>gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04.1)<li>flex 2.6.4</ul></ul></ul><p>词法分析器 Flex 可通过在 WSL 终端上输入如下指令安装。</p><pre><code class="language-bash">sudo apt install -y flex
</code></pre><h2 id="实验原理">实验原理</h2><h3 id="需要跳过的内容">需要跳过的内容</h3><pre><code class="language-bash">NEW_LINE \n|\r

COMMENT \/\*([^*]|{NEW_LINE}|(\*+([^*\/]|{NEW_LINE})))*\*+\/

SINGLE_COMMENT \/\/.*

UNICODE \\(u|U)[0-9a-fA-F]+

IDENTIFIER ({UNICODE}|[a-zA-Z_])({UNICODE}|[a-zA-Z_0-9])*
</code></pre><ol><li>flex 默认是单行匹配，所以我们要手动跳过 <code>NEW_LINE</code>。<li>C 语言的注释分为两种。其中，由 <code>/*</code>、<code>*/</code> 包裹的部分是多行注释 <code>COMMENT</code>，我参考了之前某一次作业中的<a href="https://wu-kan.cn/_posts/2020-04-28-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BA%8C/#%E8%AE%BE%E6%9C%89%E4%B8%80%E9%97%A8%E5%B0%8F%E5%B0%8F%E8%AF%AD%E8%A8%80%E4%BB%85%E5%90%AB-zo%E6%96%9C%E6%9D%A03-%E4%B8%AA%E7%AC%A6%E5%8F%B7%E8%AF%A5%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E9%87%8A%E4%BB%A5%E4%B8%80%E4%B8%AAo-%E4%B8%BA%E5%BC%80%E5%A7%8B%E6%A0%87%E8%AE%B0%E4%BB%A5%E6%AD%A4%E5%90%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-o%E4%B8%BA%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0">小小语言</a>。<li>单行注释 <code>SINGLE_COMMENT</code> 匹配的方式相对简单，没有什么可以说的。<li>标识符 <code>INDENTIFIER</code> 参照了 <a href="https://zh.cppreference.com/w/c/language/identifier">cppreference.com</a> 中的要求。此处考虑了以 <code>\u</code>或 <code>\U</code> 开始的 Unicode 字符扩展。由于是否在标识符中允许未处理（未转义）的 Unicode 字符没有在 C 语言标准中定义，此处不考虑。</ol><h3 id="整数">整数</h3><pre><code class="language-bash">HEX (\+|\-)?0(X|x)[0-9a-fA-F]+
OCTAL (\+|\-)?0[0-7]+
DECIMAL (\+|\-)?[0-9]+

INT {HEX}|{OCTAL}|{DECIMAL}
INTEGER {INT}(u|U)?(l|L|(ll)|(LL))?
</code></pre><p>参照 <a href="https://zh.cppreference.com/w/c/language/integer_constant">cppreference.com</a> 中的说法，整数常量是拥有下列类型的非左值表达式：</p><ol><li>decimal-constant integer-suffix(可选)<li>octal-constant integer-suffix(可选)<li>hex-constant integer-suffix(可选)</ol><p>其中：</p><ul><li>decimal-constant 是非零十进制数位（ 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 、 9 ），跟随零个或更多十进制数字（ 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 、 9）<li>octal-constant 是数字零（ 0 ）跟随零个或更多八进制数位（ 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 ）<li>hex-constant 是字符序列 0x 或字符序列 0X 跟随一个或更多十六进制数位（ 0 、 1 、 2 、 3、 4、 5 、 6 、 7 、 8 、 9 、 a 、 A 、 b 、 B 、 c 、 C 、 d 、 D、 e 、 E 、 f 、 F ）<li>integer-suffix ，若提供则可包含下面一或两者，可以任何顺序出现：<li>unsigned-suffix （字符 u 或字符 U ）<li>long-suffix （字符 l 或字符 L 或 long-long-suffix （字符序列 ll 或 LL ） (C99 起)</ul><p>因此匹配的时候要分十六进制、八进制、十进制三种情况考虑（<code>0B</code>打头的二进制仅由部分编译器实现，不是 C 语言标准所规定，这里不考虑）。</p><h3 id="浮点数">浮点数</h3><pre><code class="language-bash">HEX_FLOAT {HEX}(\.[0-9a-fA-F]+)?((P|p){INT})?
DECIMAL_FLOAT {DECIMAL}(\.[0-9]+)?((E|e){INT})?

FLOAT {HEX_FLOAT}|{DECIMAL_FLOAT}(f|F|l|L)?
</code></pre><p>参照 <a href="https://zh.cppreference.com/w/c/language/floating_constant">cppreference.com</a> 中的说法，浮点常量是非左值表达式，拥有下列形式：</p><ul><li>significand exponent(可选) suffix(可选)</ul><p>其中 significand 拥有形式</p><ul><li>whole-number(可选) .(可选) fraction(可选)</ul><p>exponent 拥有形式：</p><ol><li>十进制浮点常量的指数语法：e | E exponent-sign(可选) digit-sequence<li>十六进制浮点常量的指数语法：p | P exponent-sign(可选) digit-sequence (C99 起)</ol><p>因此也要分十六进制和十进制两种情况考虑。要注意的是这里指数部分为 digit-sequence，匹配的是一个数字序列，而非特定的十六进制或者十进制数。</p><h2 id="实验过程">实验过程</h2><p>Flex 通过读取一个有规定格式的<code>*.l</code>文本文件，输出一个 C 语言源程序 <code>*.yy.c</code>，再对其编译可得到可执行文件；其主要流程如下图。</p><pre><code class="language-mermaid">flowchart LR
*.l文件--flex--&gt;*.yy.c文件--c编译器--&gt;可执行文件
</code></pre><h3 id="源代码-lexl">源代码 <code>lex.l</code></h3><pre><code class="language-c">%{

#include &lt;stdio.h&gt;
int cnt_integer = 0, cnt_float = 0;

%}

NEW_LINE \n|\r

COMMENT \/\*([^*]|{NEW_LINE}|(\*+([^*\/]|{NEW_LINE})))*\*+\/

SINGLE_COMMENT \/\/.*

UNICODE \\(u|U)[0-9a-fA-F]+

IDENTIFIER ({UNICODE}|[a-zA-Z_])({UNICODE}|[a-zA-Z_0-9])*

HEX (\+|\-)?0(X|x)[0-9a-fA-F]+
OCTAL (\+|\-)?0[0-7]+
DECIMAL (\+|\-)?[0-9]+

INT {HEX}|{OCTAL}|{DECIMAL}
INTEGER {INT}(u|U)?(l|L|(ll)|(LL))?

HEX_FLOAT {HEX}(\.[0-9a-fA-F]+)?((P|p){INT})?
DECIMAL_FLOAT {DECIMAL}(\.[0-9]+)?((E|e){INT})?

FLOAT {HEX_FLOAT}|{DECIMAL_FLOAT}(f|F|l|L)?

%%

{COMMENT}|{SINGLE_COMMENT}|{IDENTIFIER}|{NEW_LINE} ;
{INTEGER} printf("No.%d integer: %s\n", ++cnt_integer, yytext);
{FLOAT} printf("No.%d float: %s\n", ++cnt_float, yytext);
. ;

%%

int yywrap() {}
int main()
{
    float \U0001f431 = +31.415926E-1F;
    /*
    3.14
    */
    //3.14
    yylex();
    printf("\n%d integer(s), %d float(s) find.", cnt_integer, cnt_float);
}
</code></pre><p>源代码，可以看到，<code>*.l</code>格式的输入文件由以下三个部分组成：</p><ol><li>由<code>%{ %}</code>包裹的 c 语言代码，其中包含第二部分匹配是需要修改的一些变量；然后预定义一些正则匹配规则。<li>每行一个正则匹配规则，以及匹配成功时「触发」的操作。<li>剩余的 C 语言代码。需要包含用户自己的 <code>yywrap</code> 函数体和 <code>main</code> 函数，且 <code>main</code> 函数需要调用 <code>yylex</code> 函数。</ol><p>上述几个部分由<code>%%</code>间隔。在 <code>main</code> 函数中，我构造了一些测试样例：使用 Unicode 扩展的变量名（不应该被识别）、浮点数 <code>+31.415926E-1F</code>（该被识别）、两个注释中的浮点数 <code>3.14</code> （不该被识别）。</p><h3 id="生成-lexyyc">生成 <code>lex.yy.c</code></h3><pre><code class="language-bash">flex lex.l
</code></pre><p>由于不同版本的 Flex 可能生成出来的结果略有差异，这里我放出我自己生成的 <code>lex.yy.c</code></p><pre><code class="language-c">
#line 3 "lex.yy.c"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION &gt; 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have &lt;inttypes.h&gt;. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include &lt;inttypes.h&gt;
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**&lt; The line count. */
    int yy_bs_column; /**&lt; The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**&lt; index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**&lt; capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**&lt; Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart ( FILE *input_file  );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
void yy_delete_buffer ( YY_BUFFER_STATE b  );
void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE-&gt;yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE-&gt;yy_at_bol)

/* Begin user sect3 */
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state ( void );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
static int yy_get_next_buffer ( void );
static void yynoreturn yy_fatal_error ( const char* msg  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 5
#define YY_END_OF_BUFFER 6
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static const flex_int16_t yy_accept[62] =
    {   0,
        0,    0,    6,    4,    1,    1,    4,    4,    2,    2,
        1,    4,    2,    2,    0,    1,    0,    2,    0,    3,
        2,    2,    0,    2,    1,    0,    0,    0,    0,    0,
        1,    3,    0,    3,    3,    2,    2,    2,    2,    0,
        1,    0,    0,    1,    3,    0,    0,    0,    1,    1,
        3,    3,    0,    3,    3,    1,    3,    3,    0,    3,
        0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        1,    1,    3,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    5,    1,    6,    7,    8,    9,   10,   10,
       10,   10,   10,   10,   10,   11,   11,    1,    1,    1,
        1,    1,    1,    1,   12,   12,   12,   12,   13,   14,
       15,   15,   15,   15,   15,   16,   15,   15,   15,   17,
       15,   15,   15,   15,   18,   15,   15,   19,   15,   15,
        1,   20,    1,    1,   15,    1,   12,   12,   12,   12,

       21,   22,   15,   15,   15,   15,   15,   23,   15,   15,
       15,   24,   15,   15,   15,   15,   25,   15,   15,   26,
       15,   15,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[27] =
    {   0,
        1,    2,    1,    1,    1,    1,    1,    1,    3,    3,
        3,    3,    3,    3,    4,    4,    4,    4,    4,    4,
        3,    3,    4,    4,    4,    4
    } ;

static const flex_int16_t yy_base[72] =
    {   0,
        0,    0,  118,  231,  231,  231,   18,   26,   28,   46,
       97,   15,    0,    0,   55,    0,   51,   22,   68,  231,
       98,   20,    0,   90,   91,   27,    0,   64,   67,   78,
        0,   78,   74,   93,  111,  231,   94,   85,  128,    0,
      145,   93,  126,  231,   54,    0,    0,  163,  166,    0,
      175,   81,  127,  190,  130,    0,    0,  138,    0,    0,
      231,  214,  218,  222,  103,   90,  226,   87,   73,   72,
       45
    } ;

static const flex_int16_t yy_def[72] =
    {   0,
       61,    1,   61,   61,   61,   61,   61,   61,   61,    9,
       62,   61,    9,   10,   63,   64,   61,   10,   61,   61,
       61,   61,   65,   61,   62,   61,   66,   63,   63,   67,
       64,   61,   61,   61,   61,   61,   61,   61,   65,   68,
       62,   63,   63,   61,   35,   69,   70,   61,   41,   41,
       69,   70,   61,   61,   61,   49,   51,   61,   71,   71,
        0,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61
    } ;

static const flex_int16_t yy_nxt[258] =
    {   0,
        4,    5,    6,    4,    7,    7,    4,    8,    9,   10,
       10,   11,   11,   11,   11,   11,   11,   11,   11,   12,
       11,   11,   11,   11,   11,   11,   13,   14,   14,   15,
       18,   18,   27,   16,   17,   37,   18,   18,   14,   27,
       19,   20,   38,   21,   40,   22,   23,   60,   19,   20,
       24,   40,   22,   23,   14,   14,   29,   29,   30,   32,
       32,   32,   45,   45,   61,   29,   29,   30,   29,   29,
       30,   61,   33,   33,   52,   51,   34,   35,   35,   43,
       43,   30,   34,   35,   35,   44,   32,   32,   32,   49,
       19,   20,   41,   20,   29,   29,   30,   48,   19,   20,

       20,   45,   45,   35,   48,   39,   20,   36,   20,   36,
       26,   46,   36,   36,   20,   20,   26,   61,   46,   35,
       35,   35,   61,   61,   20,   61,   20,   29,   29,   30,
       61,   61,   20,   20,   47,   54,   55,   55,   55,   55,
       55,   61,   61,   37,   48,   22,   58,   58,   55,   61,
       38,   48,   22,   50,   50,   50,   50,   50,   50,   61,
       61,   61,   61,   61,   26,   50,   50,   53,   53,   61,
       61,   54,   55,   55,   56,   56,   56,   56,   56,   56,
       61,   61,   61,   61,   61,   61,   56,   56,   57,   61,
       20,   61,   61,   61,   61,   61,   57,   20,   58,   58,

       55,   61,   61,   61,   61,   61,   61,   61,   59,   61,
       61,   61,   61,   61,   61,   59,   25,   25,   28,   28,
       28,   28,   31,   61,   31,   31,   42,   42,   42,   42,
        3,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61
    } ;

static const flex_int16_t yy_chk[258] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    7,    7,    7,    8,
       18,   18,   12,    8,    9,   22,    9,    9,    9,   12,
        9,    9,   22,    9,   26,    9,    9,   71,    9,    9,
        9,   26,    9,    9,   10,   10,   15,   15,   15,   17,
       17,   17,   45,   45,   10,   28,   28,   28,   29,   29,
       29,   10,   19,   19,   70,   69,   19,   19,   19,   30,
       30,   30,   33,   33,   33,   30,   32,   32,   32,   68,
       32,   32,   66,   32,   42,   42,   42,   52,   32,   32,

       32,   34,   34,   34,   52,   65,   34,   38,   34,   37,
       25,   34,   24,   21,   34,   34,   11,    3,   34,   35,
       35,   35,    0,    0,   35,    0,   35,   43,   43,   43,
        0,    0,   35,   35,   39,   53,   53,   53,   55,   55,
       55,    0,    0,   39,   39,   39,   58,   58,   58,    0,
       39,   39,   39,   41,   41,   41,   41,   41,   41,    0,
        0,    0,    0,    0,   41,   41,   41,   48,   48,    0,
        0,   48,   48,   48,   49,   49,   49,   49,   49,   49,
        0,    0,    0,    0,    0,    0,   49,   49,   51,    0,
       51,    0,    0,    0,    0,    0,   51,   51,   54,   54,

       54,    0,    0,    0,    0,    0,    0,    0,   54,    0,
        0,    0,    0,    0,    0,   54,   62,   62,   63,   63,
       63,   63,   64,    0,   64,   64,   67,   67,   67,   67,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "lex.l"
#line 2 "lex.l"

#include &lt;stdio.h&gt;
int cnt_integer = 0, cnt_float = 0;

#line 522 "lex.yy.c"
#line 523 "lex.yy.c"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include &lt;unistd.h&gt;
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals ( void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( void );

int yyget_debug ( void );

void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

			int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT

    static void yyunput ( int c, char *buf_ptr  );

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n &lt; max_size &amp;&amp; \
			     (c = getc( yyin )) != EOF &amp;&amp; c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF &amp;&amp; ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 &amp;&amp; ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;

	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE );
		}

		yy_load_buffer_state(  );
		}

	{
#line 30 "lex.l"


#line 743 "lex.yy.c"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state &gt;= 62 )
					yy_c = yy_meta[yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 231 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
/* rule 1 can match eol */
YY_RULE_SETUP
#line 32 "lex.l"
;
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 33 "lex.l"
printf("No.%d integer: %s\n",++cnt_integer, yytext);
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 34 "lex.l"
printf("No.%d float: %s\n",++cnt_float, yytext);
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 35 "lex.l"
;
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 37 "lex.l"
ECHO;
	YY_BREAK
#line 826 "lex.yy.c"
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE-&gt;yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE-&gt;yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE-&gt;yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "&lt;=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) &lt;= &amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap(  ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	char *dest = YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf;
	char *source = (yytext_ptr);
	int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) &gt; &amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);

	for ( i = 0; i &lt; number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE-&gt;yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_size - number_to_move - 1;

		while ( num_to_read &lt;= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b-&gt;yy_ch_buf);

			if ( b-&gt;yy_is_our_buffer )
				{
				int new_size = b-&gt;yy_buf_size * 2;

				if ( new_size &lt;= 0 )
					b-&gt;yy_buf_size += b-&gt;yy_buf_size / 8;
				else
					b-&gt;yy_buf_size *= 2;

				b-&gt;yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b-&gt;yy_ch_buf,
							 (yy_size_t) (b-&gt;yy_buf_size + 2)  );
				}
			else
				/* Can't grow it, we don't own it. */
				b-&gt;yy_ch_buf = NULL;

			if ( ! b-&gt;yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &amp;b-&gt;yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read &gt; YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[number_to_move]),
			(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE-&gt;yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE-&gt;yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if (((yy_n_chars) + number_to_move) &gt; YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) &gt;&gt; 1);
		YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf, (yy_size_t) new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_size = (int) (new_size - 2);
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	yy_state_type yy_current_state;
	char *yy_cp;

	yy_current_state = (yy_start);

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp &lt; (yy_c_buf_p); ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state &gt;= 62 )
				yy_c = yy_meta[yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	int yy_is_jam;
    	char *yy_cp = (yy_c_buf_p);

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state &gt;= 62 )
			yy_c = yy_meta[yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 61);

		return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp )
{
	char *yy_cp;

    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp &lt; YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = (yy_n_chars) + 2;
		char *dest = &amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_size + 2];
		char *source =
				&amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[number_to_move];

		while ( source &gt; YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE-&gt;yy_n_chars =
			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_size;

		if ( yy_cp &lt; YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;

	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) &lt; &amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap(  ) )
						return 0;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{

	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE );
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
	yy_load_buffer_state(  );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{

	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE-&gt;yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE-&gt;yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE-&gt;yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b-&gt;yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b-&gt;yy_ch_buf = (char *) yyalloc( (yy_size_t) (b-&gt;yy_buf_size + 2)  );
	if ( ! b-&gt;yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b-&gt;yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{

	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b-&gt;yy_is_our_buffer )
		yyfree( (void *) b-&gt;yy_ch_buf  );

	yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;

	yy_flush_buffer( b );

	b-&gt;yy_input_file = file;
	b-&gt;yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b-&gt;yy_bs_lineno = 1;
        b-&gt;yy_bs_column = 0;
    }

        b-&gt;yy_is_interactive = file ? (isatty( fileno(file) ) &gt; 0) : 0;

	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b-&gt;yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b-&gt;yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b-&gt;yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b-&gt;yy_buf_pos = &amp;b-&gt;yy_ch_buf[0];

	b-&gt;yy_at_bol = 1;
	b-&gt;yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state(  );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE-&gt;yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(  );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) &gt; 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state(  );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	yy_size_t num_to_alloc;

	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) &gt;= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;

	if ( size &lt; 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b-&gt;yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
	b-&gt;yy_buf_pos = b-&gt;yy_ch_buf = base;
	b-&gt;yy_is_our_buffer = 0;
	b-&gt;yy_input_file = NULL;
	b-&gt;yy_n_chars = b-&gt;yy_buf_size;
	b-&gt;yy_is_interactive = 0;
	b-&gt;yy_at_bol = 1;
	b-&gt;yy_fill_buffer = 0;
	b-&gt;yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (const char * yystr )
{

	return yy_scan_bytes( yystr, (int) strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) (_yybytes_len + 2);
	buf = (char *) yyalloc( n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i &lt; _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b-&gt;yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (const char* msg )
{
			fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno  (void)
{

    return yylineno;
}

/** Get the input stream.
 *
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 *
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 *
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 *
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno (int  _line_number )
{

    yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  _in_str )
{
        yyin = _in_str ;
}

void yyset_out (FILE *  _out_str )
{
        yyout = _out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  _bdebug )
{
        yy_flex_debug = _bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = NULL;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = NULL;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{

    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer( YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n )
{

	int i;
	for ( i = 0; i &lt; n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s )
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
			return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{

	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr )
{
			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 37 "lex.l"


int yywrap() {}
int main()
{
    float \U0001f431 = +31.415926E-1F;
    /*
    3.14
    */
    //3.14
    yylex();
    printf("\n%d integer(s), %d float(s) find.", cnt_integer, cnt_float);
}
</code></pre><h3 id="运行结果-screenlog">运行结果 <code>screen.log</code></h3><p>终端输入下述指令，生成可执行文件。</p><pre><code class="language-bash">gcc lex.yy.c -o lex
</code></pre><p>使用 <code>lex.yy.c</code> 作为输入（我 提 取 我 自 己），并将运行结果写入 <code>screen.log</code>。</p><pre><code class="language-bash">./lex &lt; lex.yy.c &gt; screen.log
</code></pre><p>可以看到我的词法分析器准确提取了输入内容的 1178 个整数和 1 个浮点数。</p><pre><code class="language-bash">No.1 integer: 3
No.2 integer: 2
No.3 integer: 6
No.4 integer: 4
No.5 integer: 0
No.6 integer: 199901L
No.7 integer: 1
No.8 integer: -128
No.9 integer: -32767
No.10 integer: -1
No.11 integer: -2147483647
No.12 integer: -1
No.13 integer: 127
No.14 integer: 32767
No.15 integer: 2147483647
No.16 integer: 255U
No.17 integer: 65535U
No.18 integer: 4294967295U
No.19 integer: 0
No.20 integer: 3
No.21 integer: 0
No.22 integer: 1
No.23 integer: 2
No.24 integer: 1
No.25 integer: 2
No.26 integer: 1
No.27 integer: 0
No.28 integer: 32768
No.29 integer: 16384
No.30 integer: 2
No.31 integer: 0
No.32 integer: 1
No.33 integer: 2
No.34 integer: 0
No.35 integer: 0
No.36 integer: 1
No.37 integer: 2
No.38 integer: 0
No.39 integer: 0
No.40 integer: 0
No.41 integer: 0
No.42 integer: 1
No.43 integer: 0
No.44 integer: 5
No.45 integer: 6
No.46 integer: 62
No.47 integer: 0
No.48 integer: 0
No.49 integer: 0
No.50 integer: 6
No.51 integer: 4
No.52 integer: 1
No.53 integer: 1
No.54 integer: 4
No.55 integer: 4
No.56 integer: 2
No.57 integer: 2
No.58 integer: 1
No.59 integer: 4
No.60 integer: 2
No.61 integer: 2
No.62 integer: 0
No.63 integer: 1
No.64 integer: 0
No.65 integer: 2
No.66 integer: 0
No.67 integer: 3
No.68 integer: 2
No.69 integer: 2
No.70 integer: 0
No.71 integer: 2
No.72 integer: 1
No.73 integer: 0
No.74 integer: 0
No.75 integer: 0
No.76 integer: 0
No.77 integer: 0
No.78 integer: 1
No.79 integer: 3
No.80 integer: 0
No.81 integer: 3
No.82 integer: 3
No.83 integer: 2
No.84 integer: 2
No.85 integer: 2
No.86 integer: 2
No.87 integer: 0
No.88 integer: 1
No.89 integer: 0
No.90 integer: 0
No.91 integer: 1
No.92 integer: 3
No.93 integer: 0
No.94 integer: 0
No.95 integer: 0
No.96 integer: 1
No.97 integer: 1
No.98 integer: 3
No.99 integer: 3
No.100 integer: 0
No.101 integer: 3
No.102 integer: 3
No.103 integer: 1
No.104 integer: 3
No.105 integer: 3
No.106 integer: 0
No.107 integer: 3
No.108 integer: 0
No.109 integer: 256
No.110 integer: 0
No.111 integer: 1
No.112 integer: 1
No.113 integer: 1
No.114 integer: 1
No.115 integer: 1
No.116 integer: 1
No.117 integer: 1
No.118 integer: 1
No.119 integer: 1
No.120 integer: 2
No.121 integer: 1
No.122 integer: 1
No.123 integer: 3
No.124 integer: 1
No.125 integer: 1
No.126 integer: 1
No.127 integer: 1
No.128 integer: 1
No.129 integer: 1
No.130 integer: 1
No.131 integer: 1
No.132 integer: 1
No.133 integer: 1
No.134 integer: 1
No.135 integer: 1
No.136 integer: 1
No.137 integer: 1
No.138 integer: 1
No.139 integer: 1
No.140 integer: 1
No.141 integer: 1
No.142 integer: 1
No.143 integer: 1
No.144 integer: 1
No.145 integer: 1
No.146 integer: 1
No.147 integer: 1
No.148 integer: 1
No.149 integer: 1
No.150 integer: 1
No.151 integer: 1
No.152 integer: 4
No.153 integer: 5
No.154 integer: 1
No.155 integer: 6
No.156 integer: 7
No.157 integer: 8
No.158 integer: 9
No.159 integer: 10
No.160 integer: 10
No.161 integer: 10
No.162 integer: 10
No.163 integer: 10
No.164 integer: 10
No.165 integer: 10
No.166 integer: 11
No.167 integer: 11
No.168 integer: 1
No.169 integer: 1
No.170 integer: 1
No.171 integer: 1
No.172 integer: 1
No.173 integer: 1
No.174 integer: 1
No.175 integer: 12
No.176 integer: 12
No.177 integer: 12
No.178 integer: 12
No.179 integer: 13
No.180 integer: 14
No.181 integer: 15
No.182 integer: 15
No.183 integer: 15
No.184 integer: 15
No.185 integer: 15
No.186 integer: 16
No.187 integer: 15
No.188 integer: 15
No.189 integer: 15
No.190 integer: 17
No.191 integer: 15
No.192 integer: 15
No.193 integer: 15
No.194 integer: 15
No.195 integer: 18
No.196 integer: 15
No.197 integer: 15
No.198 integer: 19
No.199 integer: 15
No.200 integer: 15
No.201 integer: 1
No.202 integer: 20
No.203 integer: 1
No.204 integer: 1
No.205 integer: 15
No.206 integer: 1
No.207 integer: 12
No.208 integer: 12
No.209 integer: 12
No.210 integer: 12
No.211 integer: 21
No.212 integer: 22
No.213 integer: 15
No.214 integer: 15
No.215 integer: 15
No.216 integer: 15
No.217 integer: 15
No.218 integer: 23
No.219 integer: 15
No.220 integer: 15
No.221 integer: 15
No.222 integer: 24
No.223 integer: 15
No.224 integer: 15
No.225 integer: 15
No.226 integer: 15
No.227 integer: 25
No.228 integer: 15
No.229 integer: 15
No.230 integer: 26
No.231 integer: 15
No.232 integer: 15
No.233 integer: 1
No.234 integer: 1
No.235 integer: 1
No.236 integer: 1
No.237 integer: 1
No.238 integer: 1
No.239 integer: 1
No.240 integer: 1
No.241 integer: 1
No.242 integer: 1
No.243 integer: 1
No.244 integer: 1
No.245 integer: 1
No.246 integer: 1
No.247 integer: 1
No.248 integer: 1
No.249 integer: 1
No.250 integer: 1
No.251 integer: 1
No.252 integer: 1
No.253 integer: 1
No.254 integer: 1
No.255 integer: 1
No.256 integer: 1
No.257 integer: 1
No.258 integer: 1
No.259 integer: 1
No.260 integer: 1
No.261 integer: 1
No.262 integer: 1
No.263 integer: 1
No.264 integer: 1
No.265 integer: 1
No.266 integer: 1
No.267 integer: 1
No.268 integer: 1
No.269 integer: 1
No.270 integer: 1
No.271 integer: 1
No.272 integer: 1
No.273 integer: 1
No.274 integer: 1
No.275 integer: 1
No.276 integer: 1
No.277 integer: 1
No.278 integer: 1
No.279 integer: 1
No.280 integer: 1
No.281 integer: 1
No.282 integer: 1
No.283 integer: 1
No.284 integer: 1
No.285 integer: 1
No.286 integer: 1
No.287 integer: 1
No.288 integer: 1
No.289 integer: 1
No.290 integer: 1
No.291 integer: 1
No.292 integer: 1
No.293 integer: 1
No.294 integer: 1
No.295 integer: 1
No.296 integer: 1
No.297 integer: 1
No.298 integer: 1
No.299 integer: 1
No.300 integer: 1
No.301 integer: 1
No.302 integer: 1
No.303 integer: 1
No.304 integer: 1
No.305 integer: 1
No.306 integer: 1
No.307 integer: 1
No.308 integer: 1
No.309 integer: 1
No.310 integer: 1
No.311 integer: 1
No.312 integer: 1
No.313 integer: 1
No.314 integer: 1
No.315 integer: 1
No.316 integer: 1
No.317 integer: 1
No.318 integer: 1
No.319 integer: 1
No.320 integer: 1
No.321 integer: 1
No.322 integer: 1
No.323 integer: 1
No.324 integer: 1
No.325 integer: 1
No.326 integer: 1
No.327 integer: 1
No.328 integer: 1
No.329 integer: 1
No.330 integer: 1
No.331 integer: 1
No.332 integer: 1
No.333 integer: 1
No.334 integer: 1
No.335 integer: 1
No.336 integer: 1
No.337 integer: 1
No.338 integer: 1
No.339 integer: 1
No.340 integer: 1
No.341 integer: 1
No.342 integer: 1
No.343 integer: 1
No.344 integer: 1
No.345 integer: 1
No.346 integer: 1
No.347 integer: 1
No.348 integer: 1
No.349 integer: 1
No.350 integer: 1
No.351 integer: 1
No.352 integer: 1
No.353 integer: 1
No.354 integer: 1
No.355 integer: 1
No.356 integer: 1
No.357 integer: 1
No.358 integer: 1
No.359 integer: 1
No.360 integer: 1
No.361 integer: 1
No.362 integer: 1
No.363 integer: 1
No.364 integer: 1
No.365 integer: 1
No.366 integer: 27
No.367 integer: 0
No.368 integer: 1
No.369 integer: 2
No.370 integer: 1
No.371 integer: 1
No.372 integer: 1
No.373 integer: 1
No.374 integer: 1
No.375 integer: 1
No.376 integer: 3
No.377 integer: 3
No.378 integer: 3
No.379 integer: 3
No.380 integer: 3
No.381 integer: 3
No.382 integer: 4
No.383 integer: 4
No.384 integer: 4
No.385 integer: 4
No.386 integer: 4
No.387 integer: 4
No.388 integer: 3
No.389 integer: 3
No.390 integer: 4
No.391 integer: 4
No.392 integer: 4
No.393 integer: 4
No.394 integer: 72
No.395 integer: 0
No.396 integer: 0
No.397 integer: 0
No.398 integer: 118
No.399 integer: 231
No.400 integer: 231
No.401 integer: 231
No.402 integer: 18
No.403 integer: 26
No.404 integer: 28
No.405 integer: 46
No.406 integer: 97
No.407 integer: 15
No.408 integer: 0
No.409 integer: 0
No.410 integer: 55
No.411 integer: 0
No.412 integer: 51
No.413 integer: 22
No.414 integer: 68
No.415 integer: 231
No.416 integer: 98
No.417 integer: 20
No.418 integer: 0
No.419 integer: 90
No.420 integer: 91
No.421 integer: 27
No.422 integer: 0
No.423 integer: 64
No.424 integer: 67
No.425 integer: 78
No.426 integer: 0
No.427 integer: 78
No.428 integer: 74
No.429 integer: 93
No.430 integer: 111
No.431 integer: 231
No.432 integer: 94
No.433 integer: 85
No.434 integer: 128
No.435 integer: 0
No.436 integer: 145
No.437 integer: 93
No.438 integer: 126
No.439 integer: 231
No.440 integer: 54
No.441 integer: 0
No.442 integer: 0
No.443 integer: 163
No.444 integer: 166
No.445 integer: 0
No.446 integer: 175
No.447 integer: 81
No.448 integer: 127
No.449 integer: 190
No.450 integer: 130
No.451 integer: 0
No.452 integer: 0
No.453 integer: 138
No.454 integer: 0
No.455 integer: 0
No.456 integer: 231
No.457 integer: 214
No.458 integer: 218
No.459 integer: 222
No.460 integer: 103
No.461 integer: 90
No.462 integer: 226
No.463 integer: 87
No.464 integer: 73
No.465 integer: 72
No.466 integer: 45
No.467 integer: 72
No.468 integer: 0
No.469 integer: 61
No.470 integer: 1
No.471 integer: 61
No.472 integer: 61
No.473 integer: 61
No.474 integer: 61
No.475 integer: 61
No.476 integer: 61
No.477 integer: 61
No.478 integer: 9
No.479 integer: 62
No.480 integer: 61
No.481 integer: 9
No.482 integer: 10
No.483 integer: 63
No.484 integer: 64
No.485 integer: 61
No.486 integer: 10
No.487 integer: 61
No.488 integer: 61
No.489 integer: 61
No.490 integer: 61
No.491 integer: 65
No.492 integer: 61
No.493 integer: 62
No.494 integer: 61
No.495 integer: 66
No.496 integer: 63
No.497 integer: 63
No.498 integer: 67
No.499 integer: 64
No.500 integer: 61
No.501 integer: 61
No.502 integer: 61
No.503 integer: 61
No.504 integer: 61
No.505 integer: 61
No.506 integer: 61
No.507 integer: 65
No.508 integer: 68
No.509 integer: 62
No.510 integer: 63
No.511 integer: 63
No.512 integer: 61
No.513 integer: 35
No.514 integer: 69
No.515 integer: 70
No.516 integer: 61
No.517 integer: 41
No.518 integer: 41
No.519 integer: 69
No.520 integer: 70
No.521 integer: 61
No.522 integer: 61
No.523 integer: 61
No.524 integer: 49
No.525 integer: 51
No.526 integer: 61
No.527 integer: 71
No.528 integer: 71
No.529 integer: 0
No.530 integer: 61
No.531 integer: 61
No.532 integer: 61
No.533 integer: 61
No.534 integer: 61
No.535 integer: 61
No.536 integer: 61
No.537 integer: 61
No.538 integer: 61
No.539 integer: 61
No.540 integer: 258
No.541 integer: 0
No.542 integer: 4
No.543 integer: 5
No.544 integer: 6
No.545 integer: 4
No.546 integer: 7
No.547 integer: 7
No.548 integer: 4
No.549 integer: 8
No.550 integer: 9
No.551 integer: 10
No.552 integer: 10
No.553 integer: 11
No.554 integer: 11
No.555 integer: 11
No.556 integer: 11
No.557 integer: 11
No.558 integer: 11
No.559 integer: 11
No.560 integer: 11
No.561 integer: 12
No.562 integer: 11
No.563 integer: 11
No.564 integer: 11
No.565 integer: 11
No.566 integer: 11
No.567 integer: 11
No.568 integer: 13
No.569 integer: 14
No.570 integer: 14
No.571 integer: 15
No.572 integer: 18
No.573 integer: 18
No.574 integer: 27
No.575 integer: 16
No.576 integer: 17
No.577 integer: 37
No.578 integer: 18
No.579 integer: 18
No.580 integer: 14
No.581 integer: 27
No.582 integer: 19
No.583 integer: 20
No.584 integer: 38
No.585 integer: 21
No.586 integer: 40
No.587 integer: 22
No.588 integer: 23
No.589 integer: 60
No.590 integer: 19
No.591 integer: 20
No.592 integer: 24
No.593 integer: 40
No.594 integer: 22
No.595 integer: 23
No.596 integer: 14
No.597 integer: 14
No.598 integer: 29
No.599 integer: 29
No.600 integer: 30
No.601 integer: 32
No.602 integer: 32
No.603 integer: 32
No.604 integer: 45
No.605 integer: 45
No.606 integer: 61
No.607 integer: 29
No.608 integer: 29
No.609 integer: 30
No.610 integer: 29
No.611 integer: 29
No.612 integer: 30
No.613 integer: 61
No.614 integer: 33
No.615 integer: 33
No.616 integer: 52
No.617 integer: 51
No.618 integer: 34
No.619 integer: 35
No.620 integer: 35
No.621 integer: 43
No.622 integer: 43
No.623 integer: 30
No.624 integer: 34
No.625 integer: 35
No.626 integer: 35
No.627 integer: 44
No.628 integer: 32
No.629 integer: 32
No.630 integer: 32
No.631 integer: 49
No.632 integer: 19
No.633 integer: 20
No.634 integer: 41
No.635 integer: 20
No.636 integer: 29
No.637 integer: 29
No.638 integer: 30
No.639 integer: 48
No.640 integer: 19
No.641 integer: 20
No.642 integer: 20
No.643 integer: 45
No.644 integer: 45
No.645 integer: 35
No.646 integer: 48
No.647 integer: 39
No.648 integer: 20
No.649 integer: 36
No.650 integer: 20
No.651 integer: 36
No.652 integer: 26
No.653 integer: 46
No.654 integer: 36
No.655 integer: 36
No.656 integer: 20
No.657 integer: 20
No.658 integer: 26
No.659 integer: 61
No.660 integer: 46
No.661 integer: 35
No.662 integer: 35
No.663 integer: 35
No.664 integer: 61
No.665 integer: 61
No.666 integer: 20
No.667 integer: 61
No.668 integer: 20
No.669 integer: 29
No.670 integer: 29
No.671 integer: 30
No.672 integer: 61
No.673 integer: 61
No.674 integer: 20
No.675 integer: 20
No.676 integer: 47
No.677 integer: 54
No.678 integer: 55
No.679 integer: 55
No.680 integer: 55
No.681 integer: 55
No.682 integer: 55
No.683 integer: 61
No.684 integer: 61
No.685 integer: 37
No.686 integer: 48
No.687 integer: 22
No.688 integer: 58
No.689 integer: 58
No.690 integer: 55
No.691 integer: 61
No.692 integer: 38
No.693 integer: 48
No.694 integer: 22
No.695 integer: 50
No.696 integer: 50
No.697 integer: 50
No.698 integer: 50
No.699 integer: 50
No.700 integer: 50
No.701 integer: 61
No.702 integer: 61
No.703 integer: 61
No.704 integer: 61
No.705 integer: 61
No.706 integer: 26
No.707 integer: 50
No.708 integer: 50
No.709 integer: 53
No.710 integer: 53
No.711 integer: 61
No.712 integer: 61
No.713 integer: 54
No.714 integer: 55
No.715 integer: 55
No.716 integer: 56
No.717 integer: 56
No.718 integer: 56
No.719 integer: 56
No.720 integer: 56
No.721 integer: 56
No.722 integer: 61
No.723 integer: 61
No.724 integer: 61
No.725 integer: 61
No.726 integer: 61
No.727 integer: 61
No.728 integer: 56
No.729 integer: 56
No.730 integer: 57
No.731 integer: 61
No.732 integer: 20
No.733 integer: 61
No.734 integer: 61
No.735 integer: 61
No.736 integer: 61
No.737 integer: 61
No.738 integer: 57
No.739 integer: 20
No.740 integer: 58
No.741 integer: 58
No.742 integer: 55
No.743 integer: 61
No.744 integer: 61
No.745 integer: 61
No.746 integer: 61
No.747 integer: 61
No.748 integer: 61
No.749 integer: 61
No.750 integer: 59
No.751 integer: 61
No.752 integer: 61
No.753 integer: 61
No.754 integer: 61
No.755 integer: 61
No.756 integer: 61
No.757 integer: 59
No.758 integer: 25
No.759 integer: 25
No.760 integer: 28
No.761 integer: 28
No.762 integer: 28
No.763 integer: 28
No.764 integer: 31
No.765 integer: 61
No.766 integer: 31
No.767 integer: 31
No.768 integer: 42
No.769 integer: 42
No.770 integer: 42
No.771 integer: 42
No.772 integer: 3
No.773 integer: 61
No.774 integer: 61
No.775 integer: 61
No.776 integer: 61
No.777 integer: 61
No.778 integer: 61
No.779 integer: 61
No.780 integer: 61
No.781 integer: 61
No.782 integer: 61
No.783 integer: 61
No.784 integer: 61
No.785 integer: 61
No.786 integer: 61
No.787 integer: 61
No.788 integer: 61
No.789 integer: 61
No.790 integer: 61
No.791 integer: 61
No.792 integer: 61
No.793 integer: 61
No.794 integer: 61
No.795 integer: 61
No.796 integer: 61
No.797 integer: 61
No.798 integer: 61
No.799 integer: 258
No.800 integer: 0
No.801 integer: 1
No.802 integer: 1
No.803 integer: 1
No.804 integer: 1
No.805 integer: 1
No.806 integer: 1
No.807 integer: 1
No.808 integer: 1
No.809 integer: 1
No.810 integer: 1
No.811 integer: 1
No.812 integer: 1
No.813 integer: 1
No.814 integer: 1
No.815 integer: 1
No.816 integer: 1
No.817 integer: 1
No.818 integer: 1
No.819 integer: 1
No.820 integer: 1
No.821 integer: 1
No.822 integer: 1
No.823 integer: 1
No.824 integer: 1
No.825 integer: 1
No.826 integer: 1
No.827 integer: 7
No.828 integer: 7
No.829 integer: 7
No.830 integer: 8
No.831 integer: 18
No.832 integer: 18
No.833 integer: 12
No.834 integer: 8
No.835 integer: 9
No.836 integer: 22
No.837 integer: 9
No.838 integer: 9
No.839 integer: 9
No.840 integer: 12
No.841 integer: 9
No.842 integer: 9
No.843 integer: 22
No.844 integer: 9
No.845 integer: 26
No.846 integer: 9
No.847 integer: 9
No.848 integer: 71
No.849 integer: 9
No.850 integer: 9
No.851 integer: 9
No.852 integer: 26
No.853 integer: 9
No.854 integer: 9
No.855 integer: 10
No.856 integer: 10
No.857 integer: 15
No.858 integer: 15
No.859 integer: 15
No.860 integer: 17
No.861 integer: 17
No.862 integer: 17
No.863 integer: 45
No.864 integer: 45
No.865 integer: 10
No.866 integer: 28
No.867 integer: 28
No.868 integer: 28
No.869 integer: 29
No.870 integer: 29
No.871 integer: 29
No.872 integer: 10
No.873 integer: 19
No.874 integer: 19
No.875 integer: 70
No.876 integer: 69
No.877 integer: 19
No.878 integer: 19
No.879 integer: 19
No.880 integer: 30
No.881 integer: 30
No.882 integer: 30
No.883 integer: 33
No.884 integer: 33
No.885 integer: 33
No.886 integer: 30
No.887 integer: 32
No.888 integer: 32
No.889 integer: 32
No.890 integer: 68
No.891 integer: 32
No.892 integer: 32
No.893 integer: 66
No.894 integer: 32
No.895 integer: 42
No.896 integer: 42
No.897 integer: 42
No.898 integer: 52
No.899 integer: 32
No.900 integer: 32
No.901 integer: 32
No.902 integer: 34
No.903 integer: 34
No.904 integer: 34
No.905 integer: 52
No.906 integer: 65
No.907 integer: 34
No.908 integer: 38
No.909 integer: 34
No.910 integer: 37
No.911 integer: 25
No.912 integer: 34
No.913 integer: 24
No.914 integer: 21
No.915 integer: 34
No.916 integer: 34
No.917 integer: 11
No.918 integer: 3
No.919 integer: 34
No.920 integer: 35
No.921 integer: 35
No.922 integer: 35
No.923 integer: 0
No.924 integer: 0
No.925 integer: 35
No.926 integer: 0
No.927 integer: 35
No.928 integer: 43
No.929 integer: 43
No.930 integer: 43
No.931 integer: 0
No.932 integer: 0
No.933 integer: 35
No.934 integer: 35
No.935 integer: 39
No.936 integer: 53
No.937 integer: 53
No.938 integer: 53
No.939 integer: 55
No.940 integer: 55
No.941 integer: 55
No.942 integer: 0
No.943 integer: 0
No.944 integer: 39
No.945 integer: 39
No.946 integer: 39
No.947 integer: 58
No.948 integer: 58
No.949 integer: 58
No.950 integer: 0
No.951 integer: 39
No.952 integer: 39
No.953 integer: 39
No.954 integer: 41
No.955 integer: 41
No.956 integer: 41
No.957 integer: 41
No.958 integer: 41
No.959 integer: 41
No.960 integer: 0
No.961 integer: 0
No.962 integer: 0
No.963 integer: 0
No.964 integer: 0
No.965 integer: 41
No.966 integer: 41
No.967 integer: 41
No.968 integer: 48
No.969 integer: 48
No.970 integer: 0
No.971 integer: 0
No.972 integer: 48
No.973 integer: 48
No.974 integer: 48
No.975 integer: 49
No.976 integer: 49
No.977 integer: 49
No.978 integer: 49
No.979 integer: 49
No.980 integer: 49
No.981 integer: 0
No.982 integer: 0
No.983 integer: 0
No.984 integer: 0
No.985 integer: 0
No.986 integer: 0
No.987 integer: 49
No.988 integer: 49
No.989 integer: 51
No.990 integer: 0
No.991 integer: 51
No.992 integer: 0
No.993 integer: 0
No.994 integer: 0
No.995 integer: 0
No.996 integer: 0
No.997 integer: 51
No.998 integer: 51
No.999 integer: 54
No.1000 integer: 54
No.1001 integer: 54
No.1002 integer: 0
No.1003 integer: 0
No.1004 integer: 0
No.1005 integer: 0
No.1006 integer: 0
No.1007 integer: 0
No.1008 integer: 0
No.1009 integer: 54
No.1010 integer: 0
No.1011 integer: 0
No.1012 integer: 0
No.1013 integer: 0
No.1014 integer: 0
No.1015 integer: 0
No.1016 integer: 54
No.1017 integer: 62
No.1018 integer: 62
No.1019 integer: 63
No.1020 integer: 63
No.1021 integer: 63
No.1022 integer: 63
No.1023 integer: 64
No.1024 integer: 0
No.1025 integer: 64
No.1026 integer: 64
No.1027 integer: 67
No.1028 integer: 67
No.1029 integer: 67
No.1030 integer: 67
No.1031 integer: 61
No.1032 integer: 61
No.1033 integer: 61
No.1034 integer: 61
No.1035 integer: 61
No.1036 integer: 61
No.1037 integer: 61
No.1038 integer: 61
No.1039 integer: 61
No.1040 integer: 61
No.1041 integer: 61
No.1042 integer: 61
No.1043 integer: 61
No.1044 integer: 61
No.1045 integer: 61
No.1046 integer: 61
No.1047 integer: 61
No.1048 integer: 61
No.1049 integer: 61
No.1050 integer: 61
No.1051 integer: 61
No.1052 integer: 61
No.1053 integer: 61
No.1054 integer: 61
No.1055 integer: 61
No.1056 integer: 61
No.1057 integer: 61
No.1058 integer: 0
No.1059 integer: 0
No.1060 integer: 1
No.1061 integer: 2
No.1062 integer: 0
No.1063 integer: 0
No.1064 integer: 522
No.1065 integer: 523
No.1066 integer: 0
No.1067 integer: 16384
No.1068 integer: 8192
No.1069 integer: 1
No.1070 integer: 0
No.1071 integer: 0
No.1072 integer: 0
No.1073 integer: 1
No.1074 integer: 0
No.1075 integer: 0
No.1076 integer: 25
No.1077 integer: 1
No.1078 integer: 1
No.1079 integer: 1
No.1080 integer: 30
No.1081 integer: 743
No.1082 integer: 1
No.1083 integer: 62
No.1084 integer: 231
No.1085 integer: 0
No.1086 integer: 0
No.1087 integer: 1
No.1088 integer: 32
No.1089 integer: 2
No.1090 integer: 33
No.1091 integer: 3
No.1092 integer: 34
No.1093 integer: 4
No.1094 integer: 35
No.1095 integer: 5
No.1096 integer: 37
No.1097 integer: 826
No.1098 integer: 1
No.1099 integer: 0
No.1100 integer: 1
No.1101 integer: 0
No.1102 integer: 1
No.1103 integer: 1
No.1104 integer: 0
No.1105 integer: 0
No.1106 integer: 1
No.1107 integer: 0
No.1108 integer: 2
No.1109 integer: 0
No.1110 integer: 8
No.1111 integer: 2
No.1112 integer: 2
No.1113 integer: 1
No.1114 integer: 0
No.1115 integer: 1
No.1116 integer: 2
No.1117 integer: 1
No.1118 integer: 0
No.1119 integer: 1
No.1120 integer: 62
No.1121 integer: 1
No.1122 integer: 62
No.1123 integer: 61
No.1124 integer: 0
No.1125 integer: 2
No.1126 integer: 2
No.1127 integer: 2
No.1128 integer: 2
No.1129 integer: 0
No.1130 integer: 0
No.1131 integer: 0
No.1132 integer: 1
No.1133 integer: 2
No.1134 integer: 1
No.1135 integer: 0
No.1136 integer: 1
No.1137 integer: 1
No.1138 integer: 0
No.1139 integer: 0
No.1140 integer: 0
No.1141 integer: 0
No.1142 integer: 0
No.1143 integer: 1
No.1144 integer: 0
No.1145 integer: 1
No.1146 integer: 1
No.1147 integer: 0
No.1148 integer: 1
No.1149 integer: 1
No.1150 integer: 0
No.1151 integer: 0
No.1152 integer: 1
No.1153 integer: 8
No.1154 integer: 0
No.1155 integer: 2
No.1156 integer: -2
No.1157 integer: -1
No.1158 integer: 2
No.1159 integer: 0
No.1160 integer: 0
No.1161 integer: 1
No.1162 integer: 0
No.1163 integer: 2
No.1164 integer: 0
No.1165 integer: +1
No.1166 integer: 1
No.1167 integer: 2
No.1168 integer: 0
No.1169 integer: 0
No.1170 integer: 0
No.1171 integer: 0
No.1172 integer: 0
No.1173 integer: 0
No.1174 integer: 0
No.1175 integer: 0
No.1176 integer: 0
No.1177 integer: 0
No.1178 integer: 37
No.1 float: +31.415926E-1F

1178 integer(s), 1 float(s) find.
</code></pre><h2 id="实验心得">实验心得</h2><p>通过本次实验，我实现了一个比较 naive 的 C 语言数值类型提取器，仍然存有一些可以改进的地方：</p><ol><li>默认用户输入合法，没有考虑非法情况。例如，对于输入 <code>08</code> 来说，以 0 开头的数值类型应当代表的是八进制数，而后面却跟了一个 <code>8</code>，应当有一个错误提示。然而，事实上，我的程序会把它当成两个十进制数 <code>0</code> 和 <code>8</code> 来考虑。<li>没有考虑表达式中正负号和加减号的区别。例如，对于输入 <code>1+1</code> 来说，我的程序会提取出 <code>1</code> 和 <code>+1</code> 两个数，而事实上正号是单目运算符而加号是双目运算符，两者并不能完全等价，需要基于语法分析树进行区分。</ol><p>希望日后的学习能够进一步的解决上述问题。</p></div><script repo="wu-kan/utterances-storage" src="https://utteranc.es/client.js" issue-term="url" theme="github-light" crossorigin="anonymous" async="async" ></script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" /><style> .katex-display>.katex { white-space: normal; }</style><script src="https://cdn.jsdelivr.net/combine/npm/katex@0.13.11/dist/katex.min.js,npm/katex@0.13.11/dist/contrib/auto-render.min.js" async="async" onload='renderMathInElement(document.body, { delimiters: [{left: "$$", right: "$$", display: true}, { left: "$", right: "$", display: false }, {left: "\\(", right: "\\)", display: false}, {left: "\\[", right: "\\]", display: true}]})' ></script><style> pre.language-mermaid, code.language-mermaid { display: none; } @media only screen { .mermaid { overflow: auto auto; max-width: 100%; max-height: 66.6vh; } }</style><script src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" async="async" onload=' for(let x of document.getElementsByClassName("language-mermaid")) if(x.nodeName=="CODE") { let m = document.createElement("div"); m.classList.add("mermaid"); m.textContent = x.textContent; x.parentNode.insertAdjacentElement("beforebegin", m); }' ></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.css,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.css,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.css,npm/prism-themes@1.5.0/themes/prism-nord.min.css" /> <script src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.23.0/components/prism-core.min.js,npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js,npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js,npm/prismjs@1.23.0/plugins/toolbar/prism-toolbar.min.js,npm/prismjs@1.23.0/plugins/match-braces/prism-match-braces.min.js" async="async" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/" onload=' for(let x of document.getElementsByClassName("content")) x.classList.add("line-numbers","match-braces"); Prism.plugins.toolbar.registerButton("select-code", function (env) { let button = document.createElement("button"); button.textContent = "select this " + env.language; button.addEventListener("click", function () { if (document.body.createTextRange) { let range = document.body.createTextRange(); range.moveToElementText(env.element); range.select(); } else if (window.getSelection) { let selection = window.getSelection(); let range = document.createRange(); range.selectNodeContents(env.element); selection.removeAllRanges(); selection.addRange(range); } }); return button; })' ></script></div><label for="sidebar-checkbox" class="sidebar-toggle"></label>
